// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Transaction.proto

#ifndef PROTOBUF_INCLUDED_Transaction_2eproto
#define PROTOBUF_INCLUDED_Transaction_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Transaction_2eproto 

namespace protobuf_Transaction_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Transaction_2eproto
namespace tronProtocol {
class Contract;
class ContractDefaultTypeInternal;
extern ContractDefaultTypeInternal _Contract_default_instance_;
class FreezeBalanceContract;
class FreezeBalanceContractDefaultTypeInternal;
extern FreezeBalanceContractDefaultTypeInternal _FreezeBalanceContract_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransferAssetContract;
class TransferAssetContractDefaultTypeInternal;
extern TransferAssetContractDefaultTypeInternal _TransferAssetContract_default_instance_;
class TransferContract;
class TransferContractDefaultTypeInternal;
extern TransferContractDefaultTypeInternal _TransferContract_default_instance_;
class TriggerSmartContract;
class TriggerSmartContractDefaultTypeInternal;
extern TriggerSmartContractDefaultTypeInternal _TriggerSmartContract_default_instance_;
class UnfreezeBalanceContract;
class UnfreezeBalanceContractDefaultTypeInternal;
extern UnfreezeBalanceContractDefaultTypeInternal _UnfreezeBalanceContract_default_instance_;
class raw;
class rawDefaultTypeInternal;
extern rawDefaultTypeInternal _raw_default_instance_;
}  // namespace tronProtocol
namespace google {
namespace protobuf {
template<> ::tronProtocol::Contract* Arena::CreateMaybeMessage<::tronProtocol::Contract>(Arena*);
template<> ::tronProtocol::FreezeBalanceContract* Arena::CreateMaybeMessage<::tronProtocol::FreezeBalanceContract>(Arena*);
template<> ::tronProtocol::Transaction* Arena::CreateMaybeMessage<::tronProtocol::Transaction>(Arena*);
template<> ::tronProtocol::TransferAssetContract* Arena::CreateMaybeMessage<::tronProtocol::TransferAssetContract>(Arena*);
template<> ::tronProtocol::TransferContract* Arena::CreateMaybeMessage<::tronProtocol::TransferContract>(Arena*);
template<> ::tronProtocol::TriggerSmartContract* Arena::CreateMaybeMessage<::tronProtocol::TriggerSmartContract>(Arena*);
template<> ::tronProtocol::UnfreezeBalanceContract* Arena::CreateMaybeMessage<::tronProtocol::UnfreezeBalanceContract>(Arena*);
template<> ::tronProtocol::raw* Arena::CreateMaybeMessage<::tronProtocol::raw>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tronProtocol {

enum Contract_ContractType {
  Contract_ContractType_AccountCreateContract = 0,
  Contract_ContractType_TransferContract = 1,
  Contract_ContractType_TransferAssetContract = 2,
  Contract_ContractType_VoteAssetContract = 3,
  Contract_ContractType_VoteWitnessContract = 4,
  Contract_ContractType_WitnessCreateContract = 5,
  Contract_ContractType_AssetIssueContract = 6,
  Contract_ContractType_WitnessUpdateContract = 8,
  Contract_ContractType_ParticipateAssetIssueContract = 9,
  Contract_ContractType_AccountUpdateContract = 10,
  Contract_ContractType_FreezeBalanceContract = 11,
  Contract_ContractType_UnfreezeBalanceContract = 12,
  Contract_ContractType_WithdrawBalanceContract = 13,
  Contract_ContractType_UnfreezeAssetContract = 14,
  Contract_ContractType_UpdateAssetContract = 15,
  Contract_ContractType_ProposalCreateContract = 16,
  Contract_ContractType_ProposalApproveContract = 17,
  Contract_ContractType_ProposalDeleteContract = 18,
  Contract_ContractType_SetAccountIdContract = 19,
  Contract_ContractType_CustomContract = 20,
  Contract_ContractType_CreateSmartContract = 30,
  Contract_ContractType_TriggerSmartContract = 31,
  Contract_ContractType_GetContract = 32,
  Contract_ContractType_UpdateSettingContract = 33,
  Contract_ContractType_ExchangeCreateContract = 41,
  Contract_ContractType_ExchangeInjectContract = 42,
  Contract_ContractType_ExchangeWithdrawContract = 43,
  Contract_ContractType_ExchangeTransactionContract = 44,
  Contract_ContractType_UpdateEnergyLimitContract = 45,
  Contract_ContractType_Contract_ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Contract_ContractType_Contract_ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Contract_ContractType_IsValid(int value);
const Contract_ContractType Contract_ContractType_ContractType_MIN = Contract_ContractType_AccountCreateContract;
const Contract_ContractType Contract_ContractType_ContractType_MAX = Contract_ContractType_UpdateEnergyLimitContract;
const int Contract_ContractType_ContractType_ARRAYSIZE = Contract_ContractType_ContractType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Contract_ContractType_descriptor();
inline const ::std::string& Contract_ContractType_Name(Contract_ContractType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Contract_ContractType_descriptor(), value);
}
inline bool Contract_ContractType_Parse(
    const ::std::string& name, Contract_ContractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Contract_ContractType>(
    Contract_ContractType_descriptor(), name, value);
}
enum ResourceCode {
  BANDWIDTH = 0,
  ENERGY = 1,
  ResourceCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ResourceCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ResourceCode_IsValid(int value);
const ResourceCode ResourceCode_MIN = BANDWIDTH;
const ResourceCode ResourceCode_MAX = ENERGY;
const int ResourceCode_ARRAYSIZE = ResourceCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResourceCode_descriptor();
inline const ::std::string& ResourceCode_Name(ResourceCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResourceCode_descriptor(), value);
}
inline bool ResourceCode_Parse(
    const ::std::string& name, ResourceCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResourceCode>(
    ResourceCode_descriptor(), name, value);
}
// ===================================================================

class TransferContract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronProtocol.TransferContract) */ {
 public:
  TransferContract();
  virtual ~TransferContract();

  TransferContract(const TransferContract& from);

  inline TransferContract& operator=(const TransferContract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferContract(TransferContract&& from) noexcept
    : TransferContract() {
    *this = ::std::move(from);
  }

  inline TransferContract& operator=(TransferContract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferContract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferContract* internal_default_instance() {
    return reinterpret_cast<const TransferContract*>(
               &_TransferContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TransferContract* other);
  friend void swap(TransferContract& a, TransferContract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferContract* New() const final {
    return CreateMaybeMessage<TransferContract>(NULL);
  }

  TransferContract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferContract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransferContract& from);
  void MergeFrom(const TransferContract& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferContract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes owner_address = 1;
  void clear_owner_address();
  static const int kOwnerAddressFieldNumber = 1;
  const ::std::string& owner_address() const;
  void set_owner_address(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_address(::std::string&& value);
  #endif
  void set_owner_address(const char* value);
  void set_owner_address(const void* value, size_t size);
  ::std::string* mutable_owner_address();
  ::std::string* release_owner_address();
  void set_allocated_owner_address(::std::string* owner_address);

  // bytes to_address = 2;
  void clear_to_address();
  static const int kToAddressFieldNumber = 2;
  const ::std::string& to_address() const;
  void set_to_address(const ::std::string& value);
  #if LANG_CXX11
  void set_to_address(::std::string&& value);
  #endif
  void set_to_address(const char* value);
  void set_to_address(const void* value, size_t size);
  ::std::string* mutable_to_address();
  ::std::string* release_to_address();
  void set_allocated_to_address(::std::string* to_address);

  // int64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tronProtocol.TransferContract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_address_;
  ::google::protobuf::internal::ArenaStringPtr to_address_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransferAssetContract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronProtocol.TransferAssetContract) */ {
 public:
  TransferAssetContract();
  virtual ~TransferAssetContract();

  TransferAssetContract(const TransferAssetContract& from);

  inline TransferAssetContract& operator=(const TransferAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferAssetContract(TransferAssetContract&& from) noexcept
    : TransferAssetContract() {
    *this = ::std::move(from);
  }

  inline TransferAssetContract& operator=(TransferAssetContract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferAssetContract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferAssetContract* internal_default_instance() {
    return reinterpret_cast<const TransferAssetContract*>(
               &_TransferAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TransferAssetContract* other);
  friend void swap(TransferAssetContract& a, TransferAssetContract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferAssetContract* New() const final {
    return CreateMaybeMessage<TransferAssetContract>(NULL);
  }

  TransferAssetContract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferAssetContract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransferAssetContract& from);
  void MergeFrom(const TransferAssetContract& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferAssetContract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes asset_name = 1;
  void clear_asset_name();
  static const int kAssetNameFieldNumber = 1;
  const ::std::string& asset_name() const;
  void set_asset_name(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_name(::std::string&& value);
  #endif
  void set_asset_name(const char* value);
  void set_asset_name(const void* value, size_t size);
  ::std::string* mutable_asset_name();
  ::std::string* release_asset_name();
  void set_allocated_asset_name(::std::string* asset_name);

  // bytes owner_address = 2;
  void clear_owner_address();
  static const int kOwnerAddressFieldNumber = 2;
  const ::std::string& owner_address() const;
  void set_owner_address(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_address(::std::string&& value);
  #endif
  void set_owner_address(const char* value);
  void set_owner_address(const void* value, size_t size);
  ::std::string* mutable_owner_address();
  ::std::string* release_owner_address();
  void set_allocated_owner_address(::std::string* owner_address);

  // bytes to_address = 3;
  void clear_to_address();
  static const int kToAddressFieldNumber = 3;
  const ::std::string& to_address() const;
  void set_to_address(const ::std::string& value);
  #if LANG_CXX11
  void set_to_address(::std::string&& value);
  #endif
  void set_to_address(const char* value);
  void set_to_address(const void* value, size_t size);
  ::std::string* mutable_to_address();
  ::std::string* release_to_address();
  void set_allocated_to_address(::std::string* to_address);

  // int64 amount = 4;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tronProtocol.TransferAssetContract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asset_name_;
  ::google::protobuf::internal::ArenaStringPtr owner_address_;
  ::google::protobuf::internal::ArenaStringPtr to_address_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TriggerSmartContract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronProtocol.TriggerSmartContract) */ {
 public:
  TriggerSmartContract();
  virtual ~TriggerSmartContract();

  TriggerSmartContract(const TriggerSmartContract& from);

  inline TriggerSmartContract& operator=(const TriggerSmartContract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TriggerSmartContract(TriggerSmartContract&& from) noexcept
    : TriggerSmartContract() {
    *this = ::std::move(from);
  }

  inline TriggerSmartContract& operator=(TriggerSmartContract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TriggerSmartContract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TriggerSmartContract* internal_default_instance() {
    return reinterpret_cast<const TriggerSmartContract*>(
               &_TriggerSmartContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TriggerSmartContract* other);
  friend void swap(TriggerSmartContract& a, TriggerSmartContract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TriggerSmartContract* New() const final {
    return CreateMaybeMessage<TriggerSmartContract>(NULL);
  }

  TriggerSmartContract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TriggerSmartContract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TriggerSmartContract& from);
  void MergeFrom(const TriggerSmartContract& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriggerSmartContract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes owner_address = 1;
  void clear_owner_address();
  static const int kOwnerAddressFieldNumber = 1;
  const ::std::string& owner_address() const;
  void set_owner_address(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_address(::std::string&& value);
  #endif
  void set_owner_address(const char* value);
  void set_owner_address(const void* value, size_t size);
  ::std::string* mutable_owner_address();
  ::std::string* release_owner_address();
  void set_allocated_owner_address(::std::string* owner_address);

  // bytes contract_address = 2;
  void clear_contract_address();
  static const int kContractAddressFieldNumber = 2;
  const ::std::string& contract_address() const;
  void set_contract_address(const ::std::string& value);
  #if LANG_CXX11
  void set_contract_address(::std::string&& value);
  #endif
  void set_contract_address(const char* value);
  void set_contract_address(const void* value, size_t size);
  ::std::string* mutable_contract_address();
  ::std::string* release_contract_address();
  void set_allocated_contract_address(::std::string* contract_address);

  // bytes data = 4;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int64 call_value = 3;
  void clear_call_value();
  static const int kCallValueFieldNumber = 3;
  ::google::protobuf::int64 call_value() const;
  void set_call_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tronProtocol.TriggerSmartContract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_address_;
  ::google::protobuf::internal::ArenaStringPtr contract_address_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 call_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FreezeBalanceContract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronProtocol.FreezeBalanceContract) */ {
 public:
  FreezeBalanceContract();
  virtual ~FreezeBalanceContract();

  FreezeBalanceContract(const FreezeBalanceContract& from);

  inline FreezeBalanceContract& operator=(const FreezeBalanceContract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FreezeBalanceContract(FreezeBalanceContract&& from) noexcept
    : FreezeBalanceContract() {
    *this = ::std::move(from);
  }

  inline FreezeBalanceContract& operator=(FreezeBalanceContract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreezeBalanceContract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreezeBalanceContract* internal_default_instance() {
    return reinterpret_cast<const FreezeBalanceContract*>(
               &_FreezeBalanceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FreezeBalanceContract* other);
  friend void swap(FreezeBalanceContract& a, FreezeBalanceContract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FreezeBalanceContract* New() const final {
    return CreateMaybeMessage<FreezeBalanceContract>(NULL);
  }

  FreezeBalanceContract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FreezeBalanceContract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FreezeBalanceContract& from);
  void MergeFrom(const FreezeBalanceContract& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreezeBalanceContract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes owner_address = 1;
  void clear_owner_address();
  static const int kOwnerAddressFieldNumber = 1;
  const ::std::string& owner_address() const;
  void set_owner_address(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_address(::std::string&& value);
  #endif
  void set_owner_address(const char* value);
  void set_owner_address(const void* value, size_t size);
  ::std::string* mutable_owner_address();
  ::std::string* release_owner_address();
  void set_allocated_owner_address(::std::string* owner_address);

  // bytes receiver_address = 15;
  void clear_receiver_address();
  static const int kReceiverAddressFieldNumber = 15;
  const ::std::string& receiver_address() const;
  void set_receiver_address(const ::std::string& value);
  #if LANG_CXX11
  void set_receiver_address(::std::string&& value);
  #endif
  void set_receiver_address(const char* value);
  void set_receiver_address(const void* value, size_t size);
  ::std::string* mutable_receiver_address();
  ::std::string* release_receiver_address();
  void set_allocated_receiver_address(::std::string* receiver_address);

  // int64 frozen_balance = 2;
  void clear_frozen_balance();
  static const int kFrozenBalanceFieldNumber = 2;
  ::google::protobuf::int64 frozen_balance() const;
  void set_frozen_balance(::google::protobuf::int64 value);

  // int64 frozen_duration = 3;
  void clear_frozen_duration();
  static const int kFrozenDurationFieldNumber = 3;
  ::google::protobuf::int64 frozen_duration() const;
  void set_frozen_duration(::google::protobuf::int64 value);

  // .tronProtocol.ResourceCode resource = 10;
  void clear_resource();
  static const int kResourceFieldNumber = 10;
  ::tronProtocol::ResourceCode resource() const;
  void set_resource(::tronProtocol::ResourceCode value);

  // @@protoc_insertion_point(class_scope:tronProtocol.FreezeBalanceContract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_address_;
  ::google::protobuf::internal::ArenaStringPtr receiver_address_;
  ::google::protobuf::int64 frozen_balance_;
  ::google::protobuf::int64 frozen_duration_;
  int resource_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnfreezeBalanceContract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronProtocol.UnfreezeBalanceContract) */ {
 public:
  UnfreezeBalanceContract();
  virtual ~UnfreezeBalanceContract();

  UnfreezeBalanceContract(const UnfreezeBalanceContract& from);

  inline UnfreezeBalanceContract& operator=(const UnfreezeBalanceContract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnfreezeBalanceContract(UnfreezeBalanceContract&& from) noexcept
    : UnfreezeBalanceContract() {
    *this = ::std::move(from);
  }

  inline UnfreezeBalanceContract& operator=(UnfreezeBalanceContract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnfreezeBalanceContract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnfreezeBalanceContract* internal_default_instance() {
    return reinterpret_cast<const UnfreezeBalanceContract*>(
               &_UnfreezeBalanceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UnfreezeBalanceContract* other);
  friend void swap(UnfreezeBalanceContract& a, UnfreezeBalanceContract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnfreezeBalanceContract* New() const final {
    return CreateMaybeMessage<UnfreezeBalanceContract>(NULL);
  }

  UnfreezeBalanceContract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnfreezeBalanceContract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnfreezeBalanceContract& from);
  void MergeFrom(const UnfreezeBalanceContract& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnfreezeBalanceContract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes owner_address = 1;
  void clear_owner_address();
  static const int kOwnerAddressFieldNumber = 1;
  const ::std::string& owner_address() const;
  void set_owner_address(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_address(::std::string&& value);
  #endif
  void set_owner_address(const char* value);
  void set_owner_address(const void* value, size_t size);
  ::std::string* mutable_owner_address();
  ::std::string* release_owner_address();
  void set_allocated_owner_address(::std::string* owner_address);

  // bytes receiver_address = 15;
  void clear_receiver_address();
  static const int kReceiverAddressFieldNumber = 15;
  const ::std::string& receiver_address() const;
  void set_receiver_address(const ::std::string& value);
  #if LANG_CXX11
  void set_receiver_address(::std::string&& value);
  #endif
  void set_receiver_address(const char* value);
  void set_receiver_address(const void* value, size_t size);
  ::std::string* mutable_receiver_address();
  ::std::string* release_receiver_address();
  void set_allocated_receiver_address(::std::string* receiver_address);

  // .tronProtocol.ResourceCode resource = 10;
  void clear_resource();
  static const int kResourceFieldNumber = 10;
  ::tronProtocol::ResourceCode resource() const;
  void set_resource(::tronProtocol::ResourceCode value);

  // @@protoc_insertion_point(class_scope:tronProtocol.UnfreezeBalanceContract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_address_;
  ::google::protobuf::internal::ArenaStringPtr receiver_address_;
  int resource_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Contract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronProtocol.Contract) */ {
 public:
  Contract();
  virtual ~Contract();

  Contract(const Contract& from);

  inline Contract& operator=(const Contract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Contract(Contract&& from) noexcept
    : Contract() {
    *this = ::std::move(from);
  }

  inline Contract& operator=(Contract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Contract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Contract* internal_default_instance() {
    return reinterpret_cast<const Contract*>(
               &_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Contract* other);
  friend void swap(Contract& a, Contract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Contract* New() const final {
    return CreateMaybeMessage<Contract>(NULL);
  }

  Contract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Contract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Contract& from);
  void MergeFrom(const Contract& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Contract_ContractType ContractType;
  static const ContractType AccountCreateContract =
    Contract_ContractType_AccountCreateContract;
  static const ContractType TransferContract =
    Contract_ContractType_TransferContract;
  static const ContractType TransferAssetContract =
    Contract_ContractType_TransferAssetContract;
  static const ContractType VoteAssetContract =
    Contract_ContractType_VoteAssetContract;
  static const ContractType VoteWitnessContract =
    Contract_ContractType_VoteWitnessContract;
  static const ContractType WitnessCreateContract =
    Contract_ContractType_WitnessCreateContract;
  static const ContractType AssetIssueContract =
    Contract_ContractType_AssetIssueContract;
  static const ContractType WitnessUpdateContract =
    Contract_ContractType_WitnessUpdateContract;
  static const ContractType ParticipateAssetIssueContract =
    Contract_ContractType_ParticipateAssetIssueContract;
  static const ContractType AccountUpdateContract =
    Contract_ContractType_AccountUpdateContract;
  static const ContractType FreezeBalanceContract =
    Contract_ContractType_FreezeBalanceContract;
  static const ContractType UnfreezeBalanceContract =
    Contract_ContractType_UnfreezeBalanceContract;
  static const ContractType WithdrawBalanceContract =
    Contract_ContractType_WithdrawBalanceContract;
  static const ContractType UnfreezeAssetContract =
    Contract_ContractType_UnfreezeAssetContract;
  static const ContractType UpdateAssetContract =
    Contract_ContractType_UpdateAssetContract;
  static const ContractType ProposalCreateContract =
    Contract_ContractType_ProposalCreateContract;
  static const ContractType ProposalApproveContract =
    Contract_ContractType_ProposalApproveContract;
  static const ContractType ProposalDeleteContract =
    Contract_ContractType_ProposalDeleteContract;
  static const ContractType SetAccountIdContract =
    Contract_ContractType_SetAccountIdContract;
  static const ContractType CustomContract =
    Contract_ContractType_CustomContract;
  static const ContractType CreateSmartContract =
    Contract_ContractType_CreateSmartContract;
  static const ContractType TriggerSmartContract =
    Contract_ContractType_TriggerSmartContract;
  static const ContractType GetContract =
    Contract_ContractType_GetContract;
  static const ContractType UpdateSettingContract =
    Contract_ContractType_UpdateSettingContract;
  static const ContractType ExchangeCreateContract =
    Contract_ContractType_ExchangeCreateContract;
  static const ContractType ExchangeInjectContract =
    Contract_ContractType_ExchangeInjectContract;
  static const ContractType ExchangeWithdrawContract =
    Contract_ContractType_ExchangeWithdrawContract;
  static const ContractType ExchangeTransactionContract =
    Contract_ContractType_ExchangeTransactionContract;
  static const ContractType UpdateEnergyLimitContract =
    Contract_ContractType_UpdateEnergyLimitContract;
  static inline bool ContractType_IsValid(int value) {
    return Contract_ContractType_IsValid(value);
  }
  static const ContractType ContractType_MIN =
    Contract_ContractType_ContractType_MIN;
  static const ContractType ContractType_MAX =
    Contract_ContractType_ContractType_MAX;
  static const int ContractType_ARRAYSIZE =
    Contract_ContractType_ContractType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ContractType_descriptor() {
    return Contract_ContractType_descriptor();
  }
  static inline const ::std::string& ContractType_Name(ContractType value) {
    return Contract_ContractType_Name(value);
  }
  static inline bool ContractType_Parse(const ::std::string& name,
      ContractType* value) {
    return Contract_ContractType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.protobuf.Any parameter = 2;
  bool has_parameter() const;
  void clear_parameter();
  static const int kParameterFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_parameter() const;
  public:
  const ::google::protobuf::Any& parameter() const;
  ::google::protobuf::Any* release_parameter();
  ::google::protobuf::Any* mutable_parameter();
  void set_allocated_parameter(::google::protobuf::Any* parameter);

  // .tronProtocol.Contract.ContractType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tronProtocol::Contract_ContractType type() const;
  void set_type(::tronProtocol::Contract_ContractType value);

  // @@protoc_insertion_point(class_scope:tronProtocol.Contract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* parameter_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class raw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronProtocol.raw) */ {
 public:
  raw();
  virtual ~raw();

  raw(const raw& from);

  inline raw& operator=(const raw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  raw(raw&& from) noexcept
    : raw() {
    *this = ::std::move(from);
  }

  inline raw& operator=(raw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const raw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const raw* internal_default_instance() {
    return reinterpret_cast<const raw*>(
               &_raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(raw* other);
  friend void swap(raw& a, raw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline raw* New() const final {
    return CreateMaybeMessage<raw>(NULL);
  }

  raw* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<raw>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const raw& from);
  void MergeFrom(const raw& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(raw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes ref_block_bytes = 1;
  void clear_ref_block_bytes();
  static const int kRefBlockBytesFieldNumber = 1;
  const ::std::string& ref_block_bytes() const;
  void set_ref_block_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_block_bytes(::std::string&& value);
  #endif
  void set_ref_block_bytes(const char* value);
  void set_ref_block_bytes(const void* value, size_t size);
  ::std::string* mutable_ref_block_bytes();
  ::std::string* release_ref_block_bytes();
  void set_allocated_ref_block_bytes(::std::string* ref_block_bytes);

  // bytes ref_block_hash = 4;
  void clear_ref_block_hash();
  static const int kRefBlockHashFieldNumber = 4;
  const ::std::string& ref_block_hash() const;
  void set_ref_block_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_block_hash(::std::string&& value);
  #endif
  void set_ref_block_hash(const char* value);
  void set_ref_block_hash(const void* value, size_t size);
  ::std::string* mutable_ref_block_hash();
  ::std::string* release_ref_block_hash();
  void set_allocated_ref_block_hash(::std::string* ref_block_hash);

  // .tronProtocol.Contract contract = 11;
  bool has_contract() const;
  void clear_contract();
  static const int kContractFieldNumber = 11;
  private:
  const ::tronProtocol::Contract& _internal_contract() const;
  public:
  const ::tronProtocol::Contract& contract() const;
  ::tronProtocol::Contract* release_contract();
  ::tronProtocol::Contract* mutable_contract();
  void set_allocated_contract(::tronProtocol::Contract* contract);

  // int64 expiration = 8;
  void clear_expiration();
  static const int kExpirationFieldNumber = 8;
  ::google::protobuf::int64 expiration() const;
  void set_expiration(::google::protobuf::int64 value);

  // int64 timestamp = 14;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 14;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 fee_limit = 18;
  void clear_fee_limit();
  static const int kFeeLimitFieldNumber = 18;
  ::google::protobuf::int64 fee_limit() const;
  void set_fee_limit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tronProtocol.raw)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ref_block_bytes_;
  ::google::protobuf::internal::ArenaStringPtr ref_block_hash_;
  ::tronProtocol::Contract* contract_;
  ::google::protobuf::int64 expiration_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 fee_limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronProtocol.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(NULL);
  }

  Transaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // .tronProtocol.raw raw_data = 1;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 1;
  private:
  const ::tronProtocol::raw& _internal_raw_data() const;
  public:
  const ::tronProtocol::raw& raw_data() const;
  ::tronProtocol::raw* release_raw_data();
  ::tronProtocol::raw* mutable_raw_data();
  void set_allocated_raw_data(::tronProtocol::raw* raw_data);

  // @@protoc_insertion_point(class_scope:tronProtocol.Transaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::tronProtocol::raw* raw_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Transaction_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TransferContract

// bytes owner_address = 1;
inline void TransferContract::clear_owner_address() {
  owner_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferContract::owner_address() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TransferContract.owner_address)
  return owner_address_.GetNoArena();
}
inline void TransferContract::set_owner_address(const ::std::string& value) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.TransferContract.owner_address)
}
#if LANG_CXX11
inline void TransferContract::set_owner_address(::std::string&& value) {
  
  owner_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.TransferContract.owner_address)
}
#endif
inline void TransferContract::set_owner_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.TransferContract.owner_address)
}
inline void TransferContract::set_owner_address(const void* value, size_t size) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.TransferContract.owner_address)
}
inline ::std::string* TransferContract::mutable_owner_address() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.TransferContract.owner_address)
  return owner_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:tronProtocol.TransferContract.owner_address)
  
  return owner_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferContract::set_allocated_owner_address(::std::string* owner_address) {
  if (owner_address != NULL) {
    
  } else {
    
  }
  owner_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_address);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.TransferContract.owner_address)
}

// bytes to_address = 2;
inline void TransferContract::clear_to_address() {
  to_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferContract::to_address() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TransferContract.to_address)
  return to_address_.GetNoArena();
}
inline void TransferContract::set_to_address(const ::std::string& value) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.TransferContract.to_address)
}
#if LANG_CXX11
inline void TransferContract::set_to_address(::std::string&& value) {
  
  to_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.TransferContract.to_address)
}
#endif
inline void TransferContract::set_to_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.TransferContract.to_address)
}
inline void TransferContract::set_to_address(const void* value, size_t size) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.TransferContract.to_address)
}
inline ::std::string* TransferContract::mutable_to_address() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.TransferContract.to_address)
  return to_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferContract::release_to_address() {
  // @@protoc_insertion_point(field_release:tronProtocol.TransferContract.to_address)
  
  return to_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferContract::set_allocated_to_address(::std::string* to_address) {
  if (to_address != NULL) {
    
  } else {
    
  }
  to_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_address);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.TransferContract.to_address)
}

// int64 amount = 3;
inline void TransferContract::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TransferContract::amount() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TransferContract.amount)
  return amount_;
}
inline void TransferContract::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.TransferContract.amount)
}

// -------------------------------------------------------------------

// TransferAssetContract

// bytes asset_name = 1;
inline void TransferAssetContract::clear_asset_name() {
  asset_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAssetContract::asset_name() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TransferAssetContract.asset_name)
  return asset_name_.GetNoArena();
}
inline void TransferAssetContract::set_asset_name(const ::std::string& value) {
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.TransferAssetContract.asset_name)
}
#if LANG_CXX11
inline void TransferAssetContract::set_asset_name(::std::string&& value) {
  
  asset_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.TransferAssetContract.asset_name)
}
#endif
inline void TransferAssetContract::set_asset_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.TransferAssetContract.asset_name)
}
inline void TransferAssetContract::set_asset_name(const void* value, size_t size) {
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.TransferAssetContract.asset_name)
}
inline ::std::string* TransferAssetContract::mutable_asset_name() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.TransferAssetContract.asset_name)
  return asset_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAssetContract::release_asset_name() {
  // @@protoc_insertion_point(field_release:tronProtocol.TransferAssetContract.asset_name)
  
  return asset_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAssetContract::set_allocated_asset_name(::std::string* asset_name) {
  if (asset_name != NULL) {
    
  } else {
    
  }
  asset_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_name);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.TransferAssetContract.asset_name)
}

// bytes owner_address = 2;
inline void TransferAssetContract::clear_owner_address() {
  owner_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TransferAssetContract.owner_address)
  return owner_address_.GetNoArena();
}
inline void TransferAssetContract::set_owner_address(const ::std::string& value) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.TransferAssetContract.owner_address)
}
#if LANG_CXX11
inline void TransferAssetContract::set_owner_address(::std::string&& value) {
  
  owner_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.TransferAssetContract.owner_address)
}
#endif
inline void TransferAssetContract::set_owner_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.TransferAssetContract.owner_address)
}
inline void TransferAssetContract::set_owner_address(const void* value, size_t size) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.TransferAssetContract.owner_address)
}
inline ::std::string* TransferAssetContract::mutable_owner_address() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.TransferAssetContract.owner_address)
  return owner_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:tronProtocol.TransferAssetContract.owner_address)
  
  return owner_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAssetContract::set_allocated_owner_address(::std::string* owner_address) {
  if (owner_address != NULL) {
    
  } else {
    
  }
  owner_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_address);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.TransferAssetContract.owner_address)
}

// bytes to_address = 3;
inline void TransferAssetContract::clear_to_address() {
  to_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAssetContract::to_address() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TransferAssetContract.to_address)
  return to_address_.GetNoArena();
}
inline void TransferAssetContract::set_to_address(const ::std::string& value) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.TransferAssetContract.to_address)
}
#if LANG_CXX11
inline void TransferAssetContract::set_to_address(::std::string&& value) {
  
  to_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.TransferAssetContract.to_address)
}
#endif
inline void TransferAssetContract::set_to_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.TransferAssetContract.to_address)
}
inline void TransferAssetContract::set_to_address(const void* value, size_t size) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.TransferAssetContract.to_address)
}
inline ::std::string* TransferAssetContract::mutable_to_address() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.TransferAssetContract.to_address)
  return to_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAssetContract::release_to_address() {
  // @@protoc_insertion_point(field_release:tronProtocol.TransferAssetContract.to_address)
  
  return to_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAssetContract::set_allocated_to_address(::std::string* to_address) {
  if (to_address != NULL) {
    
  } else {
    
  }
  to_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_address);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.TransferAssetContract.to_address)
}

// int64 amount = 4;
inline void TransferAssetContract::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TransferAssetContract::amount() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TransferAssetContract.amount)
  return amount_;
}
inline void TransferAssetContract::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.TransferAssetContract.amount)
}

// -------------------------------------------------------------------

// TriggerSmartContract

// bytes owner_address = 1;
inline void TriggerSmartContract::clear_owner_address() {
  owner_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TriggerSmartContract::owner_address() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TriggerSmartContract.owner_address)
  return owner_address_.GetNoArena();
}
inline void TriggerSmartContract::set_owner_address(const ::std::string& value) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.TriggerSmartContract.owner_address)
}
#if LANG_CXX11
inline void TriggerSmartContract::set_owner_address(::std::string&& value) {
  
  owner_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.TriggerSmartContract.owner_address)
}
#endif
inline void TriggerSmartContract::set_owner_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.TriggerSmartContract.owner_address)
}
inline void TriggerSmartContract::set_owner_address(const void* value, size_t size) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.TriggerSmartContract.owner_address)
}
inline ::std::string* TriggerSmartContract::mutable_owner_address() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.TriggerSmartContract.owner_address)
  return owner_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TriggerSmartContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:tronProtocol.TriggerSmartContract.owner_address)
  
  return owner_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TriggerSmartContract::set_allocated_owner_address(::std::string* owner_address) {
  if (owner_address != NULL) {
    
  } else {
    
  }
  owner_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_address);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.TriggerSmartContract.owner_address)
}

// bytes contract_address = 2;
inline void TriggerSmartContract::clear_contract_address() {
  contract_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TriggerSmartContract::contract_address() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TriggerSmartContract.contract_address)
  return contract_address_.GetNoArena();
}
inline void TriggerSmartContract::set_contract_address(const ::std::string& value) {
  
  contract_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.TriggerSmartContract.contract_address)
}
#if LANG_CXX11
inline void TriggerSmartContract::set_contract_address(::std::string&& value) {
  
  contract_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.TriggerSmartContract.contract_address)
}
#endif
inline void TriggerSmartContract::set_contract_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contract_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.TriggerSmartContract.contract_address)
}
inline void TriggerSmartContract::set_contract_address(const void* value, size_t size) {
  
  contract_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.TriggerSmartContract.contract_address)
}
inline ::std::string* TriggerSmartContract::mutable_contract_address() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.TriggerSmartContract.contract_address)
  return contract_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TriggerSmartContract::release_contract_address() {
  // @@protoc_insertion_point(field_release:tronProtocol.TriggerSmartContract.contract_address)
  
  return contract_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TriggerSmartContract::set_allocated_contract_address(::std::string* contract_address) {
  if (contract_address != NULL) {
    
  } else {
    
  }
  contract_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract_address);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.TriggerSmartContract.contract_address)
}

// int64 call_value = 3;
inline void TriggerSmartContract::clear_call_value() {
  call_value_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TriggerSmartContract::call_value() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TriggerSmartContract.call_value)
  return call_value_;
}
inline void TriggerSmartContract::set_call_value(::google::protobuf::int64 value) {
  
  call_value_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.TriggerSmartContract.call_value)
}

// bytes data = 4;
inline void TriggerSmartContract::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TriggerSmartContract::data() const {
  // @@protoc_insertion_point(field_get:tronProtocol.TriggerSmartContract.data)
  return data_.GetNoArena();
}
inline void TriggerSmartContract::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.TriggerSmartContract.data)
}
#if LANG_CXX11
inline void TriggerSmartContract::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.TriggerSmartContract.data)
}
#endif
inline void TriggerSmartContract::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.TriggerSmartContract.data)
}
inline void TriggerSmartContract::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.TriggerSmartContract.data)
}
inline ::std::string* TriggerSmartContract::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.TriggerSmartContract.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TriggerSmartContract::release_data() {
  // @@protoc_insertion_point(field_release:tronProtocol.TriggerSmartContract.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TriggerSmartContract::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.TriggerSmartContract.data)
}

// -------------------------------------------------------------------

// FreezeBalanceContract

// bytes owner_address = 1;
inline void FreezeBalanceContract::clear_owner_address() {
  owner_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FreezeBalanceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:tronProtocol.FreezeBalanceContract.owner_address)
  return owner_address_.GetNoArena();
}
inline void FreezeBalanceContract::set_owner_address(const ::std::string& value) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.FreezeBalanceContract.owner_address)
}
#if LANG_CXX11
inline void FreezeBalanceContract::set_owner_address(::std::string&& value) {
  
  owner_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.FreezeBalanceContract.owner_address)
}
#endif
inline void FreezeBalanceContract::set_owner_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.FreezeBalanceContract.owner_address)
}
inline void FreezeBalanceContract::set_owner_address(const void* value, size_t size) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.FreezeBalanceContract.owner_address)
}
inline ::std::string* FreezeBalanceContract::mutable_owner_address() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.FreezeBalanceContract.owner_address)
  return owner_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FreezeBalanceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:tronProtocol.FreezeBalanceContract.owner_address)
  
  return owner_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FreezeBalanceContract::set_allocated_owner_address(::std::string* owner_address) {
  if (owner_address != NULL) {
    
  } else {
    
  }
  owner_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_address);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.FreezeBalanceContract.owner_address)
}

// int64 frozen_balance = 2;
inline void FreezeBalanceContract::clear_frozen_balance() {
  frozen_balance_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FreezeBalanceContract::frozen_balance() const {
  // @@protoc_insertion_point(field_get:tronProtocol.FreezeBalanceContract.frozen_balance)
  return frozen_balance_;
}
inline void FreezeBalanceContract::set_frozen_balance(::google::protobuf::int64 value) {
  
  frozen_balance_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.FreezeBalanceContract.frozen_balance)
}

// int64 frozen_duration = 3;
inline void FreezeBalanceContract::clear_frozen_duration() {
  frozen_duration_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FreezeBalanceContract::frozen_duration() const {
  // @@protoc_insertion_point(field_get:tronProtocol.FreezeBalanceContract.frozen_duration)
  return frozen_duration_;
}
inline void FreezeBalanceContract::set_frozen_duration(::google::protobuf::int64 value) {
  
  frozen_duration_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.FreezeBalanceContract.frozen_duration)
}

// .tronProtocol.ResourceCode resource = 10;
inline void FreezeBalanceContract::clear_resource() {
  resource_ = 0;
}
inline ::tronProtocol::ResourceCode FreezeBalanceContract::resource() const {
  // @@protoc_insertion_point(field_get:tronProtocol.FreezeBalanceContract.resource)
  return static_cast< ::tronProtocol::ResourceCode >(resource_);
}
inline void FreezeBalanceContract::set_resource(::tronProtocol::ResourceCode value) {
  
  resource_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.FreezeBalanceContract.resource)
}

// bytes receiver_address = 15;
inline void FreezeBalanceContract::clear_receiver_address() {
  receiver_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FreezeBalanceContract::receiver_address() const {
  // @@protoc_insertion_point(field_get:tronProtocol.FreezeBalanceContract.receiver_address)
  return receiver_address_.GetNoArena();
}
inline void FreezeBalanceContract::set_receiver_address(const ::std::string& value) {
  
  receiver_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.FreezeBalanceContract.receiver_address)
}
#if LANG_CXX11
inline void FreezeBalanceContract::set_receiver_address(::std::string&& value) {
  
  receiver_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.FreezeBalanceContract.receiver_address)
}
#endif
inline void FreezeBalanceContract::set_receiver_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  receiver_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.FreezeBalanceContract.receiver_address)
}
inline void FreezeBalanceContract::set_receiver_address(const void* value, size_t size) {
  
  receiver_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.FreezeBalanceContract.receiver_address)
}
inline ::std::string* FreezeBalanceContract::mutable_receiver_address() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.FreezeBalanceContract.receiver_address)
  return receiver_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FreezeBalanceContract::release_receiver_address() {
  // @@protoc_insertion_point(field_release:tronProtocol.FreezeBalanceContract.receiver_address)
  
  return receiver_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FreezeBalanceContract::set_allocated_receiver_address(::std::string* receiver_address) {
  if (receiver_address != NULL) {
    
  } else {
    
  }
  receiver_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receiver_address);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.FreezeBalanceContract.receiver_address)
}

// -------------------------------------------------------------------

// UnfreezeBalanceContract

// bytes owner_address = 1;
inline void UnfreezeBalanceContract::clear_owner_address() {
  owner_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnfreezeBalanceContract::owner_address() const {
  // @@protoc_insertion_point(field_get:tronProtocol.UnfreezeBalanceContract.owner_address)
  return owner_address_.GetNoArena();
}
inline void UnfreezeBalanceContract::set_owner_address(const ::std::string& value) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.UnfreezeBalanceContract.owner_address)
}
#if LANG_CXX11
inline void UnfreezeBalanceContract::set_owner_address(::std::string&& value) {
  
  owner_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.UnfreezeBalanceContract.owner_address)
}
#endif
inline void UnfreezeBalanceContract::set_owner_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.UnfreezeBalanceContract.owner_address)
}
inline void UnfreezeBalanceContract::set_owner_address(const void* value, size_t size) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.UnfreezeBalanceContract.owner_address)
}
inline ::std::string* UnfreezeBalanceContract::mutable_owner_address() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.UnfreezeBalanceContract.owner_address)
  return owner_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnfreezeBalanceContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:tronProtocol.UnfreezeBalanceContract.owner_address)
  
  return owner_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnfreezeBalanceContract::set_allocated_owner_address(::std::string* owner_address) {
  if (owner_address != NULL) {
    
  } else {
    
  }
  owner_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_address);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.UnfreezeBalanceContract.owner_address)
}

// .tronProtocol.ResourceCode resource = 10;
inline void UnfreezeBalanceContract::clear_resource() {
  resource_ = 0;
}
inline ::tronProtocol::ResourceCode UnfreezeBalanceContract::resource() const {
  // @@protoc_insertion_point(field_get:tronProtocol.UnfreezeBalanceContract.resource)
  return static_cast< ::tronProtocol::ResourceCode >(resource_);
}
inline void UnfreezeBalanceContract::set_resource(::tronProtocol::ResourceCode value) {
  
  resource_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.UnfreezeBalanceContract.resource)
}

// bytes receiver_address = 15;
inline void UnfreezeBalanceContract::clear_receiver_address() {
  receiver_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnfreezeBalanceContract::receiver_address() const {
  // @@protoc_insertion_point(field_get:tronProtocol.UnfreezeBalanceContract.receiver_address)
  return receiver_address_.GetNoArena();
}
inline void UnfreezeBalanceContract::set_receiver_address(const ::std::string& value) {
  
  receiver_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.UnfreezeBalanceContract.receiver_address)
}
#if LANG_CXX11
inline void UnfreezeBalanceContract::set_receiver_address(::std::string&& value) {
  
  receiver_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.UnfreezeBalanceContract.receiver_address)
}
#endif
inline void UnfreezeBalanceContract::set_receiver_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  receiver_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.UnfreezeBalanceContract.receiver_address)
}
inline void UnfreezeBalanceContract::set_receiver_address(const void* value, size_t size) {
  
  receiver_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.UnfreezeBalanceContract.receiver_address)
}
inline ::std::string* UnfreezeBalanceContract::mutable_receiver_address() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.UnfreezeBalanceContract.receiver_address)
  return receiver_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnfreezeBalanceContract::release_receiver_address() {
  // @@protoc_insertion_point(field_release:tronProtocol.UnfreezeBalanceContract.receiver_address)
  
  return receiver_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnfreezeBalanceContract::set_allocated_receiver_address(::std::string* receiver_address) {
  if (receiver_address != NULL) {
    
  } else {
    
  }
  receiver_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receiver_address);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.UnfreezeBalanceContract.receiver_address)
}

// -------------------------------------------------------------------

// Contract

// .tronProtocol.Contract.ContractType type = 1;
inline void Contract::clear_type() {
  type_ = 0;
}
inline ::tronProtocol::Contract_ContractType Contract::type() const {
  // @@protoc_insertion_point(field_get:tronProtocol.Contract.type)
  return static_cast< ::tronProtocol::Contract_ContractType >(type_);
}
inline void Contract::set_type(::tronProtocol::Contract_ContractType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.Contract.type)
}

// .google.protobuf.Any parameter = 2;
inline bool Contract::has_parameter() const {
  return this != internal_default_instance() && parameter_ != NULL;
}
inline const ::google::protobuf::Any& Contract::_internal_parameter() const {
  return *parameter_;
}
inline const ::google::protobuf::Any& Contract::parameter() const {
  const ::google::protobuf::Any* p = parameter_;
  // @@protoc_insertion_point(field_get:tronProtocol.Contract.parameter)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Contract::release_parameter() {
  // @@protoc_insertion_point(field_release:tronProtocol.Contract.parameter)
  
  ::google::protobuf::Any* temp = parameter_;
  parameter_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* Contract::mutable_parameter() {
  
  if (parameter_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    parameter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tronProtocol.Contract.parameter)
  return parameter_;
}
inline void Contract::set_allocated_parameter(::google::protobuf::Any* parameter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(parameter_);
  }
  if (parameter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parameter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parameter, submessage_arena);
    }
    
  } else {
    
  }
  parameter_ = parameter;
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.Contract.parameter)
}

// -------------------------------------------------------------------

// raw

// bytes ref_block_bytes = 1;
inline void raw::clear_ref_block_bytes() {
  ref_block_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& raw::ref_block_bytes() const {
  // @@protoc_insertion_point(field_get:tronProtocol.raw.ref_block_bytes)
  return ref_block_bytes_.GetNoArena();
}
inline void raw::set_ref_block_bytes(const ::std::string& value) {
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.raw.ref_block_bytes)
}
#if LANG_CXX11
inline void raw::set_ref_block_bytes(::std::string&& value) {
  
  ref_block_bytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.raw.ref_block_bytes)
}
#endif
inline void raw::set_ref_block_bytes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.raw.ref_block_bytes)
}
inline void raw::set_ref_block_bytes(const void* value, size_t size) {
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.raw.ref_block_bytes)
}
inline ::std::string* raw::mutable_ref_block_bytes() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.raw.ref_block_bytes)
  return ref_block_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* raw::release_ref_block_bytes() {
  // @@protoc_insertion_point(field_release:tronProtocol.raw.ref_block_bytes)
  
  return ref_block_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void raw::set_allocated_ref_block_bytes(::std::string* ref_block_bytes) {
  if (ref_block_bytes != NULL) {
    
  } else {
    
  }
  ref_block_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_block_bytes);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.raw.ref_block_bytes)
}

// bytes ref_block_hash = 4;
inline void raw::clear_ref_block_hash() {
  ref_block_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& raw::ref_block_hash() const {
  // @@protoc_insertion_point(field_get:tronProtocol.raw.ref_block_hash)
  return ref_block_hash_.GetNoArena();
}
inline void raw::set_ref_block_hash(const ::std::string& value) {
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.raw.ref_block_hash)
}
#if LANG_CXX11
inline void raw::set_ref_block_hash(::std::string&& value) {
  
  ref_block_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.raw.ref_block_hash)
}
#endif
inline void raw::set_ref_block_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.raw.ref_block_hash)
}
inline void raw::set_ref_block_hash(const void* value, size_t size) {
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.raw.ref_block_hash)
}
inline ::std::string* raw::mutable_ref_block_hash() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.raw.ref_block_hash)
  return ref_block_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* raw::release_ref_block_hash() {
  // @@protoc_insertion_point(field_release:tronProtocol.raw.ref_block_hash)
  
  return ref_block_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void raw::set_allocated_ref_block_hash(::std::string* ref_block_hash) {
  if (ref_block_hash != NULL) {
    
  } else {
    
  }
  ref_block_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_block_hash);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.raw.ref_block_hash)
}

// int64 expiration = 8;
inline void raw::clear_expiration() {
  expiration_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 raw::expiration() const {
  // @@protoc_insertion_point(field_get:tronProtocol.raw.expiration)
  return expiration_;
}
inline void raw::set_expiration(::google::protobuf::int64 value) {
  
  expiration_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.raw.expiration)
}

// .tronProtocol.Contract contract = 11;
inline bool raw::has_contract() const {
  return this != internal_default_instance() && contract_ != NULL;
}
inline void raw::clear_contract() {
  if (GetArenaNoVirtual() == NULL && contract_ != NULL) {
    delete contract_;
  }
  contract_ = NULL;
}
inline const ::tronProtocol::Contract& raw::_internal_contract() const {
  return *contract_;
}
inline const ::tronProtocol::Contract& raw::contract() const {
  const ::tronProtocol::Contract* p = contract_;
  // @@protoc_insertion_point(field_get:tronProtocol.raw.contract)
  return p != NULL ? *p : *reinterpret_cast<const ::tronProtocol::Contract*>(
      &::tronProtocol::_Contract_default_instance_);
}
inline ::tronProtocol::Contract* raw::release_contract() {
  // @@protoc_insertion_point(field_release:tronProtocol.raw.contract)
  
  ::tronProtocol::Contract* temp = contract_;
  contract_ = NULL;
  return temp;
}
inline ::tronProtocol::Contract* raw::mutable_contract() {
  
  if (contract_ == NULL) {
    auto* p = CreateMaybeMessage<::tronProtocol::Contract>(GetArenaNoVirtual());
    contract_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tronProtocol.raw.contract)
  return contract_;
}
inline void raw::set_allocated_contract(::tronProtocol::Contract* contract) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete contract_;
  }
  if (contract) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contract = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    
  } else {
    
  }
  contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.raw.contract)
}

// int64 timestamp = 14;
inline void raw::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 raw::timestamp() const {
  // @@protoc_insertion_point(field_get:tronProtocol.raw.timestamp)
  return timestamp_;
}
inline void raw::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.raw.timestamp)
}

// int64 fee_limit = 18;
inline void raw::clear_fee_limit() {
  fee_limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 raw::fee_limit() const {
  // @@protoc_insertion_point(field_get:tronProtocol.raw.fee_limit)
  return fee_limit_;
}
inline void raw::set_fee_limit(::google::protobuf::int64 value) {
  
  fee_limit_ = value;
  // @@protoc_insertion_point(field_set:tronProtocol.raw.fee_limit)
}

// -------------------------------------------------------------------

// Transaction

// .tronProtocol.raw raw_data = 1;
inline bool Transaction::has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != NULL;
}
inline void Transaction::clear_raw_data() {
  if (GetArenaNoVirtual() == NULL && raw_data_ != NULL) {
    delete raw_data_;
  }
  raw_data_ = NULL;
}
inline const ::tronProtocol::raw& Transaction::_internal_raw_data() const {
  return *raw_data_;
}
inline const ::tronProtocol::raw& Transaction::raw_data() const {
  const ::tronProtocol::raw* p = raw_data_;
  // @@protoc_insertion_point(field_get:tronProtocol.Transaction.raw_data)
  return p != NULL ? *p : *reinterpret_cast<const ::tronProtocol::raw*>(
      &::tronProtocol::_raw_default_instance_);
}
inline ::tronProtocol::raw* Transaction::release_raw_data() {
  // @@protoc_insertion_point(field_release:tronProtocol.Transaction.raw_data)
  
  ::tronProtocol::raw* temp = raw_data_;
  raw_data_ = NULL;
  return temp;
}
inline ::tronProtocol::raw* Transaction::mutable_raw_data() {
  
  if (raw_data_ == NULL) {
    auto* p = CreateMaybeMessage<::tronProtocol::raw>(GetArenaNoVirtual());
    raw_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tronProtocol.Transaction.raw_data)
  return raw_data_;
}
inline void Transaction::set_allocated_raw_data(::tronProtocol::raw* raw_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete raw_data_;
  }
  if (raw_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      raw_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.Transaction.raw_data)
}

// bytes signature = 2;
inline void Transaction::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::signature() const {
  // @@protoc_insertion_point(field_get:tronProtocol.Transaction.signature)
  return signature_.GetNoArena();
}
inline void Transaction::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronProtocol.Transaction.signature)
}
#if LANG_CXX11
inline void Transaction::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronProtocol.Transaction.signature)
}
#endif
inline void Transaction::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronProtocol.Transaction.signature)
}
inline void Transaction::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronProtocol.Transaction.signature)
}
inline ::std::string* Transaction::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:tronProtocol.Transaction.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_signature() {
  // @@protoc_insertion_point(field_release:tronProtocol.Transaction.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:tronProtocol.Transaction.signature)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tronProtocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tronProtocol::Contract_ContractType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronProtocol::Contract_ContractType>() {
  return ::tronProtocol::Contract_ContractType_descriptor();
}
template <> struct is_proto_enum< ::tronProtocol::ResourceCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronProtocol::ResourceCode>() {
  return ::tronProtocol::ResourceCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Transaction_2eproto
