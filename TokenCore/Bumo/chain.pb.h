// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chain.proto

#ifndef PROTOBUF_INCLUDED_chain_2eproto
#define PROTOBUF_INCLUDED_chain_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_chain_2eproto 

namespace protobuf_chain_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[30];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_chain_2eproto
namespace bumoProtocol {
class Account;
class AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class AccountPrivilege;
class AccountPrivilegeDefaultTypeInternal;
extern AccountPrivilegeDefaultTypeInternal _AccountPrivilege_default_instance_;
class AccountThreshold;
class AccountThresholdDefaultTypeInternal;
extern AccountThresholdDefaultTypeInternal _AccountThreshold_default_instance_;
class Asset;
class AssetDefaultTypeInternal;
extern AssetDefaultTypeInternal _Asset_default_instance_;
class AssetKey;
class AssetKeyDefaultTypeInternal;
extern AssetKeyDefaultTypeInternal _AssetKey_default_instance_;
class AssetProperty;
class AssetPropertyDefaultTypeInternal;
extern AssetPropertyDefaultTypeInternal _AssetProperty_default_instance_;
class AssetStore;
class AssetStoreDefaultTypeInternal;
extern AssetStoreDefaultTypeInternal _AssetStore_default_instance_;
class ConsensusValue;
class ConsensusValueDefaultTypeInternal;
extern ConsensusValueDefaultTypeInternal _ConsensusValue_default_instance_;
class ConsensusValueValidation;
class ConsensusValueValidationDefaultTypeInternal;
extern ConsensusValueValidationDefaultTypeInternal _ConsensusValueValidation_default_instance_;
class Contract;
class ContractDefaultTypeInternal;
extern ContractDefaultTypeInternal _Contract_default_instance_;
class Ledger;
class LedgerDefaultTypeInternal;
extern LedgerDefaultTypeInternal _Ledger_default_instance_;
class LedgerHeader;
class LedgerHeaderDefaultTypeInternal;
extern LedgerHeaderDefaultTypeInternal _LedgerHeader_default_instance_;
class Operation;
class OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class OperationCreateAccount;
class OperationCreateAccountDefaultTypeInternal;
extern OperationCreateAccountDefaultTypeInternal _OperationCreateAccount_default_instance_;
class OperationIssueAsset;
class OperationIssueAssetDefaultTypeInternal;
extern OperationIssueAssetDefaultTypeInternal _OperationIssueAsset_default_instance_;
class OperationLog;
class OperationLogDefaultTypeInternal;
extern OperationLogDefaultTypeInternal _OperationLog_default_instance_;
class OperationPayAsset;
class OperationPayAssetDefaultTypeInternal;
extern OperationPayAssetDefaultTypeInternal _OperationPayAsset_default_instance_;
class OperationPayCoin;
class OperationPayCoinDefaultTypeInternal;
extern OperationPayCoinDefaultTypeInternal _OperationPayCoin_default_instance_;
class OperationSetMetadata;
class OperationSetMetadataDefaultTypeInternal;
extern OperationSetMetadataDefaultTypeInternal _OperationSetMetadata_default_instance_;
class OperationSetPrivilege;
class OperationSetPrivilegeDefaultTypeInternal;
extern OperationSetPrivilegeDefaultTypeInternal _OperationSetPrivilege_default_instance_;
class OperationSetSignerWeight;
class OperationSetSignerWeightDefaultTypeInternal;
extern OperationSetSignerWeightDefaultTypeInternal _OperationSetSignerWeight_default_instance_;
class OperationSetThreshold;
class OperationSetThresholdDefaultTypeInternal;
extern OperationSetThresholdDefaultTypeInternal _OperationSetThreshold_default_instance_;
class OperationTypeThreshold;
class OperationTypeThresholdDefaultTypeInternal;
extern OperationTypeThresholdDefaultTypeInternal _OperationTypeThreshold_default_instance_;
class Signer;
class SignerDefaultTypeInternal;
extern SignerDefaultTypeInternal _Signer_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransactionEnv;
class TransactionEnvDefaultTypeInternal;
extern TransactionEnvDefaultTypeInternal _TransactionEnv_default_instance_;
class TransactionEnvSet;
class TransactionEnvSetDefaultTypeInternal;
extern TransactionEnvSetDefaultTypeInternal _TransactionEnvSet_default_instance_;
class TransactionEnvStore;
class TransactionEnvStoreDefaultTypeInternal;
extern TransactionEnvStoreDefaultTypeInternal _TransactionEnvStore_default_instance_;
class Trigger;
class TriggerDefaultTypeInternal;
extern TriggerDefaultTypeInternal _Trigger_default_instance_;
class Trigger_OperationTrigger;
class Trigger_OperationTriggerDefaultTypeInternal;
extern Trigger_OperationTriggerDefaultTypeInternal _Trigger_OperationTrigger_default_instance_;
}  // namespace bumoProtocol
namespace google {
namespace protobuf {
template<> ::bumoProtocol::Account* Arena::CreateMaybeMessage<::bumoProtocol::Account>(Arena*);
template<> ::bumoProtocol::AccountPrivilege* Arena::CreateMaybeMessage<::bumoProtocol::AccountPrivilege>(Arena*);
template<> ::bumoProtocol::AccountThreshold* Arena::CreateMaybeMessage<::bumoProtocol::AccountThreshold>(Arena*);
template<> ::bumoProtocol::Asset* Arena::CreateMaybeMessage<::bumoProtocol::Asset>(Arena*);
template<> ::bumoProtocol::AssetKey* Arena::CreateMaybeMessage<::bumoProtocol::AssetKey>(Arena*);
template<> ::bumoProtocol::AssetProperty* Arena::CreateMaybeMessage<::bumoProtocol::AssetProperty>(Arena*);
template<> ::bumoProtocol::AssetStore* Arena::CreateMaybeMessage<::bumoProtocol::AssetStore>(Arena*);
template<> ::bumoProtocol::ConsensusValue* Arena::CreateMaybeMessage<::bumoProtocol::ConsensusValue>(Arena*);
template<> ::bumoProtocol::ConsensusValueValidation* Arena::CreateMaybeMessage<::bumoProtocol::ConsensusValueValidation>(Arena*);
template<> ::bumoProtocol::Contract* Arena::CreateMaybeMessage<::bumoProtocol::Contract>(Arena*);
template<> ::bumoProtocol::Ledger* Arena::CreateMaybeMessage<::bumoProtocol::Ledger>(Arena*);
template<> ::bumoProtocol::LedgerHeader* Arena::CreateMaybeMessage<::bumoProtocol::LedgerHeader>(Arena*);
template<> ::bumoProtocol::Operation* Arena::CreateMaybeMessage<::bumoProtocol::Operation>(Arena*);
template<> ::bumoProtocol::OperationCreateAccount* Arena::CreateMaybeMessage<::bumoProtocol::OperationCreateAccount>(Arena*);
template<> ::bumoProtocol::OperationIssueAsset* Arena::CreateMaybeMessage<::bumoProtocol::OperationIssueAsset>(Arena*);
template<> ::bumoProtocol::OperationLog* Arena::CreateMaybeMessage<::bumoProtocol::OperationLog>(Arena*);
template<> ::bumoProtocol::OperationPayAsset* Arena::CreateMaybeMessage<::bumoProtocol::OperationPayAsset>(Arena*);
template<> ::bumoProtocol::OperationPayCoin* Arena::CreateMaybeMessage<::bumoProtocol::OperationPayCoin>(Arena*);
template<> ::bumoProtocol::OperationSetMetadata* Arena::CreateMaybeMessage<::bumoProtocol::OperationSetMetadata>(Arena*);
template<> ::bumoProtocol::OperationSetPrivilege* Arena::CreateMaybeMessage<::bumoProtocol::OperationSetPrivilege>(Arena*);
template<> ::bumoProtocol::OperationSetSignerWeight* Arena::CreateMaybeMessage<::bumoProtocol::OperationSetSignerWeight>(Arena*);
template<> ::bumoProtocol::OperationSetThreshold* Arena::CreateMaybeMessage<::bumoProtocol::OperationSetThreshold>(Arena*);
template<> ::bumoProtocol::OperationTypeThreshold* Arena::CreateMaybeMessage<::bumoProtocol::OperationTypeThreshold>(Arena*);
template<> ::bumoProtocol::Signer* Arena::CreateMaybeMessage<::bumoProtocol::Signer>(Arena*);
template<> ::bumoProtocol::Transaction* Arena::CreateMaybeMessage<::bumoProtocol::Transaction>(Arena*);
template<> ::bumoProtocol::TransactionEnv* Arena::CreateMaybeMessage<::bumoProtocol::TransactionEnv>(Arena*);
template<> ::bumoProtocol::TransactionEnvSet* Arena::CreateMaybeMessage<::bumoProtocol::TransactionEnvSet>(Arena*);
template<> ::bumoProtocol::TransactionEnvStore* Arena::CreateMaybeMessage<::bumoProtocol::TransactionEnvStore>(Arena*);
template<> ::bumoProtocol::Trigger* Arena::CreateMaybeMessage<::bumoProtocol::Trigger>(Arena*);
template<> ::bumoProtocol::Trigger_OperationTrigger* Arena::CreateMaybeMessage<::bumoProtocol::Trigger_OperationTrigger>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace bumoProtocol {

enum Operation_Type {
  Operation_Type_UNKNOWN = 0,
  Operation_Type_CREATE_ACCOUNT = 1,
  Operation_Type_ISSUE_ASSET = 2,
  Operation_Type_PAY_ASSET = 3,
  Operation_Type_SET_METADATA = 4,
  Operation_Type_SET_SIGNER_WEIGHT = 5,
  Operation_Type_SET_THRESHOLD = 6,
  Operation_Type_PAY_COIN = 7,
  Operation_Type_LOG = 8,
  Operation_Type_SET_PRIVILEGE = 9,
  Operation_Type_Operation_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Operation_Type_Operation_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Operation_Type_IsValid(int value);
const Operation_Type Operation_Type_Type_MIN = Operation_Type_UNKNOWN;
const Operation_Type Operation_Type_Type_MAX = Operation_Type_SET_PRIVILEGE;
const int Operation_Type_Type_ARRAYSIZE = Operation_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operation_Type_descriptor();
inline const ::std::string& Operation_Type_Name(Operation_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operation_Type_descriptor(), value);
}
inline bool Operation_Type_Parse(
    const ::std::string& name, Operation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operation_Type>(
    Operation_Type_descriptor(), name, value);
}
enum Transaction_Limit {
  Transaction_Limit_UNKNOWN = 0,
  Transaction_Limit_OPERATIONS = 1000,
  Transaction_Limit_Transaction_Limit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Transaction_Limit_Transaction_Limit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Transaction_Limit_IsValid(int value);
const Transaction_Limit Transaction_Limit_Limit_MIN = Transaction_Limit_UNKNOWN;
const Transaction_Limit Transaction_Limit_Limit_MAX = Transaction_Limit_OPERATIONS;
const int Transaction_Limit_Limit_ARRAYSIZE = Transaction_Limit_Limit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transaction_Limit_descriptor();
inline const ::std::string& Transaction_Limit_Name(Transaction_Limit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transaction_Limit_descriptor(), value);
}
inline bool Transaction_Limit_Parse(
    const ::std::string& name, Transaction_Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transaction_Limit>(
    Transaction_Limit_descriptor(), name, value);
}
enum Signer_Limit {
  Signer_Limit_SIGNER_NONE = 0,
  Signer_Limit_SIGNER = 100,
  Signer_Limit_Signer_Limit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Signer_Limit_Signer_Limit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Signer_Limit_IsValid(int value);
const Signer_Limit Signer_Limit_Limit_MIN = Signer_Limit_SIGNER_NONE;
const Signer_Limit Signer_Limit_Limit_MAX = Signer_Limit_SIGNER;
const int Signer_Limit_Limit_ARRAYSIZE = Signer_Limit_Limit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signer_Limit_descriptor();
inline const ::std::string& Signer_Limit_Name(Signer_Limit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signer_Limit_descriptor(), value);
}
inline bool Signer_Limit_Parse(
    const ::std::string& name, Signer_Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signer_Limit>(
    Signer_Limit_descriptor(), name, value);
}
enum Trigger_TransactionType {
  Trigger_TransactionType_NORMAL_TRANSACTION = 0,
  Trigger_TransactionType_CONTRACT_TRANSACTION = 1,
  Trigger_TransactionType_Trigger_TransactionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Trigger_TransactionType_Trigger_TransactionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Trigger_TransactionType_IsValid(int value);
const Trigger_TransactionType Trigger_TransactionType_TransactionType_MIN = Trigger_TransactionType_NORMAL_TRANSACTION;
const Trigger_TransactionType Trigger_TransactionType_TransactionType_MAX = Trigger_TransactionType_CONTRACT_TRANSACTION;
const int Trigger_TransactionType_TransactionType_ARRAYSIZE = Trigger_TransactionType_TransactionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Trigger_TransactionType_descriptor();
inline const ::std::string& Trigger_TransactionType_Name(Trigger_TransactionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Trigger_TransactionType_descriptor(), value);
}
inline bool Trigger_TransactionType_Parse(
    const ::std::string& name, Trigger_TransactionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Trigger_TransactionType>(
    Trigger_TransactionType_descriptor(), name, value);
}
enum Contract_ContractType {
  Contract_ContractType_JAVASCRIPT = 0,
  Contract_ContractType_Contract_ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Contract_ContractType_Contract_ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Contract_ContractType_IsValid(int value);
const Contract_ContractType Contract_ContractType_ContractType_MIN = Contract_ContractType_JAVASCRIPT;
const Contract_ContractType Contract_ContractType_ContractType_MAX = Contract_ContractType_JAVASCRIPT;
const int Contract_ContractType_ContractType_ARRAYSIZE = Contract_ContractType_ContractType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Contract_ContractType_descriptor();
inline const ::std::string& Contract_ContractType_Name(Contract_ContractType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Contract_ContractType_descriptor(), value);
}
inline bool Contract_ContractType_Parse(
    const ::std::string& name, Contract_ContractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Contract_ContractType>(
    Contract_ContractType_descriptor(), name, value);
}
enum Limit {
  UNKNOWN = 0,
  SIGNATURE = 100,
  Limit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Limit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Limit_IsValid(int value);
const Limit Limit_MIN = UNKNOWN;
const Limit Limit_MAX = SIGNATURE;
const int Limit_ARRAYSIZE = Limit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Limit_descriptor();
inline const ::std::string& Limit_Name(Limit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Limit_descriptor(), value);
}
inline bool Limit_Parse(
    const ::std::string& name, Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Limit>(
    Limit_descriptor(), name, value);
}
// ===================================================================

class Account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.Account) */ {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(Account&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Account* other);
  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Account* New() const final {
    return CreateMaybeMessage<Account>(NULL);
  }

  Account* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Account>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // bytes metadatas_hash = 4;
  void clear_metadatas_hash();
  static const int kMetadatasHashFieldNumber = 4;
  const ::std::string& metadatas_hash() const;
  void set_metadatas_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_metadatas_hash(::std::string&& value);
  #endif
  void set_metadatas_hash(const char* value);
  void set_metadatas_hash(const void* value, size_t size);
  ::std::string* mutable_metadatas_hash();
  ::std::string* release_metadatas_hash();
  void set_allocated_metadatas_hash(::std::string* metadatas_hash);

  // bytes assets_hash = 5;
  void clear_assets_hash();
  static const int kAssetsHashFieldNumber = 5;
  const ::std::string& assets_hash() const;
  void set_assets_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_assets_hash(::std::string&& value);
  #endif
  void set_assets_hash(const char* value);
  void set_assets_hash(const void* value, size_t size);
  ::std::string* mutable_assets_hash();
  ::std::string* release_assets_hash();
  void set_allocated_assets_hash(::std::string* assets_hash);

  // .bumoProtocol.AccountPrivilege priv = 3;
  bool has_priv() const;
  void clear_priv();
  static const int kPrivFieldNumber = 3;
  private:
  const ::bumoProtocol::AccountPrivilege& _internal_priv() const;
  public:
  const ::bumoProtocol::AccountPrivilege& priv() const;
  ::bumoProtocol::AccountPrivilege* release_priv();
  ::bumoProtocol::AccountPrivilege* mutable_priv();
  void set_allocated_priv(::bumoProtocol::AccountPrivilege* priv);

  // .bumoProtocol.Contract contract = 6;
  bool has_contract() const;
  void clear_contract();
  static const int kContractFieldNumber = 6;
  private:
  const ::bumoProtocol::Contract& _internal_contract() const;
  public:
  const ::bumoProtocol::Contract& contract() const;
  ::bumoProtocol::Contract* release_contract();
  ::bumoProtocol::Contract* mutable_contract();
  void set_allocated_contract(::bumoProtocol::Contract* contract);

  // int64 nonce = 2;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  ::google::protobuf::int64 nonce() const;
  void set_nonce(::google::protobuf::int64 value);

  // int64 balance = 7;
  void clear_balance();
  static const int kBalanceFieldNumber = 7;
  ::google::protobuf::int64 balance() const;
  void set_balance(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.Account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr metadatas_hash_;
  ::google::protobuf::internal::ArenaStringPtr assets_hash_;
  ::bumoProtocol::AccountPrivilege* priv_;
  ::bumoProtocol::Contract* contract_;
  ::google::protobuf::int64 nonce_;
  ::google::protobuf::int64 balance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssetKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.AssetKey) */ {
 public:
  AssetKey();
  virtual ~AssetKey();

  AssetKey(const AssetKey& from);

  inline AssetKey& operator=(const AssetKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssetKey(AssetKey&& from) noexcept
    : AssetKey() {
    *this = ::std::move(from);
  }

  inline AssetKey& operator=(AssetKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssetKey* internal_default_instance() {
    return reinterpret_cast<const AssetKey*>(
               &_AssetKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AssetKey* other);
  friend void swap(AssetKey& a, AssetKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssetKey* New() const final {
    return CreateMaybeMessage<AssetKey>(NULL);
  }

  AssetKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AssetKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AssetKey& from);
  void MergeFrom(const AssetKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string issuer = 1;
  void clear_issuer();
  static const int kIssuerFieldNumber = 1;
  const ::std::string& issuer() const;
  void set_issuer(const ::std::string& value);
  #if LANG_CXX11
  void set_issuer(::std::string&& value);
  #endif
  void set_issuer(const char* value);
  void set_issuer(const char* value, size_t size);
  ::std::string* mutable_issuer();
  ::std::string* release_issuer();
  void set_allocated_issuer(::std::string* issuer);

  // string code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // int32 type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.AssetKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr issuer_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::int32 type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Asset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.Asset) */ {
 public:
  Asset();
  virtual ~Asset();

  Asset(const Asset& from);

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Asset(Asset&& from) noexcept
    : Asset() {
    *this = ::std::move(from);
  }

  inline Asset& operator=(Asset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Asset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Asset* internal_default_instance() {
    return reinterpret_cast<const Asset*>(
               &_Asset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Asset* other);
  friend void swap(Asset& a, Asset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Asset* New() const final {
    return CreateMaybeMessage<Asset>(NULL);
  }

  Asset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Asset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Asset& from);
  void MergeFrom(const Asset& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Asset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bumoProtocol.AssetKey key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::bumoProtocol::AssetKey& _internal_key() const;
  public:
  const ::bumoProtocol::AssetKey& key() const;
  ::bumoProtocol::AssetKey* release_key();
  ::bumoProtocol::AssetKey* mutable_key();
  void set_allocated_key(::bumoProtocol::AssetKey* key);

  // int64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.Asset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bumoProtocol::AssetKey* key_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssetProperty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.AssetProperty) */ {
 public:
  AssetProperty();
  virtual ~AssetProperty();

  AssetProperty(const AssetProperty& from);

  inline AssetProperty& operator=(const AssetProperty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssetProperty(AssetProperty&& from) noexcept
    : AssetProperty() {
    *this = ::std::move(from);
  }

  inline AssetProperty& operator=(AssetProperty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetProperty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssetProperty* internal_default_instance() {
    return reinterpret_cast<const AssetProperty*>(
               &_AssetProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AssetProperty* other);
  friend void swap(AssetProperty& a, AssetProperty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssetProperty* New() const final {
    return CreateMaybeMessage<AssetProperty>(NULL);
  }

  AssetProperty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AssetProperty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AssetProperty& from);
  void MergeFrom(const AssetProperty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetProperty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string description = 2;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // int64 max_supply = 3;
  void clear_max_supply();
  static const int kMaxSupplyFieldNumber = 3;
  ::google::protobuf::int64 max_supply() const;
  void set_max_supply(::google::protobuf::int64 value);

  // int32 decimal = 1;
  void clear_decimal();
  static const int kDecimalFieldNumber = 1;
  ::google::protobuf::int32 decimal() const;
  void set_decimal(::google::protobuf::int32 value);

  // int32 fee_percent = 5;
  void clear_fee_percent();
  static const int kFeePercentFieldNumber = 5;
  ::google::protobuf::int32 fee_percent() const;
  void set_fee_percent(::google::protobuf::int32 value);

  // int64 issued_amount = 4;
  void clear_issued_amount();
  static const int kIssuedAmountFieldNumber = 4;
  ::google::protobuf::int64 issued_amount() const;
  void set_issued_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.AssetProperty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::int64 max_supply_;
  ::google::protobuf::int32 decimal_;
  ::google::protobuf::int32 fee_percent_;
  ::google::protobuf::int64 issued_amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssetStore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.AssetStore) */ {
 public:
  AssetStore();
  virtual ~AssetStore();

  AssetStore(const AssetStore& from);

  inline AssetStore& operator=(const AssetStore& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssetStore(AssetStore&& from) noexcept
    : AssetStore() {
    *this = ::std::move(from);
  }

  inline AssetStore& operator=(AssetStore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetStore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssetStore* internal_default_instance() {
    return reinterpret_cast<const AssetStore*>(
               &_AssetStore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AssetStore* other);
  friend void swap(AssetStore& a, AssetStore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssetStore* New() const final {
    return CreateMaybeMessage<AssetStore>(NULL);
  }

  AssetStore* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AssetStore>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AssetStore& from);
  void MergeFrom(const AssetStore& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetStore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bumoProtocol.AssetKey key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::bumoProtocol::AssetKey& _internal_key() const;
  public:
  const ::bumoProtocol::AssetKey& key() const;
  ::bumoProtocol::AssetKey* release_key();
  ::bumoProtocol::AssetKey* mutable_key();
  void set_allocated_key(::bumoProtocol::AssetKey* key);

  // .bumoProtocol.AssetProperty property = 3;
  bool has_property() const;
  void clear_property();
  static const int kPropertyFieldNumber = 3;
  private:
  const ::bumoProtocol::AssetProperty& _internal_property() const;
  public:
  const ::bumoProtocol::AssetProperty& property() const;
  ::bumoProtocol::AssetProperty* release_property();
  ::bumoProtocol::AssetProperty* mutable_property();
  void set_allocated_property(::bumoProtocol::AssetProperty* property);

  // int64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.AssetStore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bumoProtocol::AssetKey* key_;
  ::bumoProtocol::AssetProperty* property_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LedgerHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.LedgerHeader) */ {
 public:
  LedgerHeader();
  virtual ~LedgerHeader();

  LedgerHeader(const LedgerHeader& from);

  inline LedgerHeader& operator=(const LedgerHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LedgerHeader(LedgerHeader&& from) noexcept
    : LedgerHeader() {
    *this = ::std::move(from);
  }

  inline LedgerHeader& operator=(LedgerHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedgerHeader* internal_default_instance() {
    return reinterpret_cast<const LedgerHeader*>(
               &_LedgerHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(LedgerHeader* other);
  friend void swap(LedgerHeader& a, LedgerHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LedgerHeader* New() const final {
    return CreateMaybeMessage<LedgerHeader>(NULL);
  }

  LedgerHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LedgerHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LedgerHeader& from);
  void MergeFrom(const LedgerHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedgerHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // bytes previous_hash = 3;
  void clear_previous_hash();
  static const int kPreviousHashFieldNumber = 3;
  const ::std::string& previous_hash() const;
  void set_previous_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_previous_hash(::std::string&& value);
  #endif
  void set_previous_hash(const char* value);
  void set_previous_hash(const void* value, size_t size);
  ::std::string* mutable_previous_hash();
  ::std::string* release_previous_hash();
  void set_allocated_previous_hash(::std::string* previous_hash);

  // bytes account_tree_hash = 4;
  void clear_account_tree_hash();
  static const int kAccountTreeHashFieldNumber = 4;
  const ::std::string& account_tree_hash() const;
  void set_account_tree_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_account_tree_hash(::std::string&& value);
  #endif
  void set_account_tree_hash(const char* value);
  void set_account_tree_hash(const void* value, size_t size);
  ::std::string* mutable_account_tree_hash();
  ::std::string* release_account_tree_hash();
  void set_allocated_account_tree_hash(::std::string* account_tree_hash);

  // bytes consensus_value_hash = 6;
  void clear_consensus_value_hash();
  static const int kConsensusValueHashFieldNumber = 6;
  const ::std::string& consensus_value_hash() const;
  void set_consensus_value_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_consensus_value_hash(::std::string&& value);
  #endif
  void set_consensus_value_hash(const char* value);
  void set_consensus_value_hash(const void* value, size_t size);
  ::std::string* mutable_consensus_value_hash();
  ::std::string* release_consensus_value_hash();
  void set_allocated_consensus_value_hash(::std::string* consensus_value_hash);

  // bytes validators_hash = 9;
  void clear_validators_hash();
  static const int kValidatorsHashFieldNumber = 9;
  const ::std::string& validators_hash() const;
  void set_validators_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_validators_hash(::std::string&& value);
  #endif
  void set_validators_hash(const char* value);
  void set_validators_hash(const void* value, size_t size);
  ::std::string* mutable_validators_hash();
  ::std::string* release_validators_hash();
  void set_allocated_validators_hash(::std::string* validators_hash);

  // bytes fees_hash = 10;
  void clear_fees_hash();
  static const int kFeesHashFieldNumber = 10;
  const ::std::string& fees_hash() const;
  void set_fees_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_fees_hash(::std::string&& value);
  #endif
  void set_fees_hash(const char* value);
  void set_fees_hash(const void* value, size_t size);
  ::std::string* mutable_fees_hash();
  ::std::string* release_fees_hash();
  void set_allocated_fees_hash(::std::string* fees_hash);

  // string reserve = 11;
  void clear_reserve();
  static const int kReserveFieldNumber = 11;
  const ::std::string& reserve() const;
  void set_reserve(const ::std::string& value);
  #if LANG_CXX11
  void set_reserve(::std::string&& value);
  #endif
  void set_reserve(const char* value);
  void set_reserve(const char* value, size_t size);
  ::std::string* mutable_reserve();
  ::std::string* release_reserve();
  void set_allocated_reserve(::std::string* reserve);

  // int64 seq = 1;
  void clear_seq();
  static const int kSeqFieldNumber = 1;
  ::google::protobuf::int64 seq() const;
  void set_seq(::google::protobuf::int64 value);

  // int64 close_time = 5;
  void clear_close_time();
  static const int kCloseTimeFieldNumber = 5;
  ::google::protobuf::int64 close_time() const;
  void set_close_time(::google::protobuf::int64 value);

  // int64 version = 7;
  void clear_version();
  static const int kVersionFieldNumber = 7;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // int64 tx_count = 8;
  void clear_tx_count();
  static const int kTxCountFieldNumber = 8;
  ::google::protobuf::int64 tx_count() const;
  void set_tx_count(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.LedgerHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr previous_hash_;
  ::google::protobuf::internal::ArenaStringPtr account_tree_hash_;
  ::google::protobuf::internal::ArenaStringPtr consensus_value_hash_;
  ::google::protobuf::internal::ArenaStringPtr validators_hash_;
  ::google::protobuf::internal::ArenaStringPtr fees_hash_;
  ::google::protobuf::internal::ArenaStringPtr reserve_;
  ::google::protobuf::int64 seq_;
  ::google::protobuf::int64 close_time_;
  ::google::protobuf::int64 version_;
  ::google::protobuf::int64 tx_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ledger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.Ledger) */ {
 public:
  Ledger();
  virtual ~Ledger();

  Ledger(const Ledger& from);

  inline Ledger& operator=(const Ledger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ledger(Ledger&& from) noexcept
    : Ledger() {
    *this = ::std::move(from);
  }

  inline Ledger& operator=(Ledger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ledger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ledger* internal_default_instance() {
    return reinterpret_cast<const Ledger*>(
               &_Ledger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Ledger* other);
  friend void swap(Ledger& a, Ledger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ledger* New() const final {
    return CreateMaybeMessage<Ledger>(NULL);
  }

  Ledger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ledger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ledger& from);
  void MergeFrom(const Ledger& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ledger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bumoProtocol.TransactionEnv transaction_envs = 2;
  int transaction_envs_size() const;
  void clear_transaction_envs();
  static const int kTransactionEnvsFieldNumber = 2;
  ::bumoProtocol::TransactionEnv* mutable_transaction_envs(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::TransactionEnv >*
      mutable_transaction_envs();
  const ::bumoProtocol::TransactionEnv& transaction_envs(int index) const;
  ::bumoProtocol::TransactionEnv* add_transaction_envs();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::TransactionEnv >&
      transaction_envs() const;

  // .bumoProtocol.LedgerHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::bumoProtocol::LedgerHeader& _internal_header() const;
  public:
  const ::bumoProtocol::LedgerHeader& header() const;
  ::bumoProtocol::LedgerHeader* release_header();
  ::bumoProtocol::LedgerHeader* mutable_header();
  void set_allocated_header(::bumoProtocol::LedgerHeader* header);

  // @@protoc_insertion_point(class_scope:bumoProtocol.Ledger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::TransactionEnv > transaction_envs_;
  ::bumoProtocol::LedgerHeader* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationPayAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.OperationPayAsset) */ {
 public:
  OperationPayAsset();
  virtual ~OperationPayAsset();

  OperationPayAsset(const OperationPayAsset& from);

  inline OperationPayAsset& operator=(const OperationPayAsset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationPayAsset(OperationPayAsset&& from) noexcept
    : OperationPayAsset() {
    *this = ::std::move(from);
  }

  inline OperationPayAsset& operator=(OperationPayAsset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationPayAsset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationPayAsset* internal_default_instance() {
    return reinterpret_cast<const OperationPayAsset*>(
               &_OperationPayAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(OperationPayAsset* other);
  friend void swap(OperationPayAsset& a, OperationPayAsset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationPayAsset* New() const final {
    return CreateMaybeMessage<OperationPayAsset>(NULL);
  }

  OperationPayAsset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationPayAsset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationPayAsset& from);
  void MergeFrom(const OperationPayAsset& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationPayAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string dest_address = 1;
  void clear_dest_address();
  static const int kDestAddressFieldNumber = 1;
  const ::std::string& dest_address() const;
  void set_dest_address(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_address(::std::string&& value);
  #endif
  void set_dest_address(const char* value);
  void set_dest_address(const char* value, size_t size);
  ::std::string* mutable_dest_address();
  ::std::string* release_dest_address();
  void set_allocated_dest_address(::std::string* dest_address);

  // string input = 3;
  void clear_input();
  static const int kInputFieldNumber = 3;
  const ::std::string& input() const;
  void set_input(const ::std::string& value);
  #if LANG_CXX11
  void set_input(::std::string&& value);
  #endif
  void set_input(const char* value);
  void set_input(const char* value, size_t size);
  ::std::string* mutable_input();
  ::std::string* release_input();
  void set_allocated_input(::std::string* input);

  // .bumoProtocol.Asset asset = 2;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 2;
  private:
  const ::bumoProtocol::Asset& _internal_asset() const;
  public:
  const ::bumoProtocol::Asset& asset() const;
  ::bumoProtocol::Asset* release_asset();
  ::bumoProtocol::Asset* mutable_asset();
  void set_allocated_asset(::bumoProtocol::Asset* asset);

  // @@protoc_insertion_point(class_scope:bumoProtocol.OperationPayAsset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr dest_address_;
  ::google::protobuf::internal::ArenaStringPtr input_;
  ::bumoProtocol::Asset* asset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationTypeThreshold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.OperationTypeThreshold) */ {
 public:
  OperationTypeThreshold();
  virtual ~OperationTypeThreshold();

  OperationTypeThreshold(const OperationTypeThreshold& from);

  inline OperationTypeThreshold& operator=(const OperationTypeThreshold& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationTypeThreshold(OperationTypeThreshold&& from) noexcept
    : OperationTypeThreshold() {
    *this = ::std::move(from);
  }

  inline OperationTypeThreshold& operator=(OperationTypeThreshold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationTypeThreshold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationTypeThreshold* internal_default_instance() {
    return reinterpret_cast<const OperationTypeThreshold*>(
               &_OperationTypeThreshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(OperationTypeThreshold* other);
  friend void swap(OperationTypeThreshold& a, OperationTypeThreshold& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationTypeThreshold* New() const final {
    return CreateMaybeMessage<OperationTypeThreshold>(NULL);
  }

  OperationTypeThreshold* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationTypeThreshold>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationTypeThreshold& from);
  void MergeFrom(const OperationTypeThreshold& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationTypeThreshold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 threshold = 2;
  void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  ::google::protobuf::int64 threshold() const;
  void set_threshold(::google::protobuf::int64 value);

  // .bumoProtocol.Operation.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::bumoProtocol::Operation_Type type() const;
  void set_type(::bumoProtocol::Operation_Type value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.OperationTypeThreshold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 threshold_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountPrivilege : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.AccountPrivilege) */ {
 public:
  AccountPrivilege();
  virtual ~AccountPrivilege();

  AccountPrivilege(const AccountPrivilege& from);

  inline AccountPrivilege& operator=(const AccountPrivilege& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountPrivilege(AccountPrivilege&& from) noexcept
    : AccountPrivilege() {
    *this = ::std::move(from);
  }

  inline AccountPrivilege& operator=(AccountPrivilege&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountPrivilege& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountPrivilege* internal_default_instance() {
    return reinterpret_cast<const AccountPrivilege*>(
               &_AccountPrivilege_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AccountPrivilege* other);
  friend void swap(AccountPrivilege& a, AccountPrivilege& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountPrivilege* New() const final {
    return CreateMaybeMessage<AccountPrivilege>(NULL);
  }

  AccountPrivilege* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountPrivilege>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountPrivilege& from);
  void MergeFrom(const AccountPrivilege& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountPrivilege* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bumoProtocol.Signer signers = 2;
  int signers_size() const;
  void clear_signers();
  static const int kSignersFieldNumber = 2;
  ::bumoProtocol::Signer* mutable_signers(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >*
      mutable_signers();
  const ::bumoProtocol::Signer& signers(int index) const;
  ::bumoProtocol::Signer* add_signers();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >&
      signers() const;

  // .bumoProtocol.AccountThreshold thresholds = 3;
  bool has_thresholds() const;
  void clear_thresholds();
  static const int kThresholdsFieldNumber = 3;
  private:
  const ::bumoProtocol::AccountThreshold& _internal_thresholds() const;
  public:
  const ::bumoProtocol::AccountThreshold& thresholds() const;
  ::bumoProtocol::AccountThreshold* release_thresholds();
  ::bumoProtocol::AccountThreshold* mutable_thresholds();
  void set_allocated_thresholds(::bumoProtocol::AccountThreshold* thresholds);

  // int64 master_weight = 1;
  void clear_master_weight();
  static const int kMasterWeightFieldNumber = 1;
  ::google::protobuf::int64 master_weight() const;
  void set_master_weight(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.AccountPrivilege)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer > signers_;
  ::bumoProtocol::AccountThreshold* thresholds_;
  ::google::protobuf::int64 master_weight_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountThreshold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.AccountThreshold) */ {
 public:
  AccountThreshold();
  virtual ~AccountThreshold();

  AccountThreshold(const AccountThreshold& from);

  inline AccountThreshold& operator=(const AccountThreshold& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountThreshold(AccountThreshold&& from) noexcept
    : AccountThreshold() {
    *this = ::std::move(from);
  }

  inline AccountThreshold& operator=(AccountThreshold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountThreshold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountThreshold* internal_default_instance() {
    return reinterpret_cast<const AccountThreshold*>(
               &_AccountThreshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AccountThreshold* other);
  friend void swap(AccountThreshold& a, AccountThreshold& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountThreshold* New() const final {
    return CreateMaybeMessage<AccountThreshold>(NULL);
  }

  AccountThreshold* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountThreshold>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountThreshold& from);
  void MergeFrom(const AccountThreshold& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountThreshold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bumoProtocol.OperationTypeThreshold type_thresholds = 2;
  int type_thresholds_size() const;
  void clear_type_thresholds();
  static const int kTypeThresholdsFieldNumber = 2;
  ::bumoProtocol::OperationTypeThreshold* mutable_type_thresholds(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >*
      mutable_type_thresholds();
  const ::bumoProtocol::OperationTypeThreshold& type_thresholds(int index) const;
  ::bumoProtocol::OperationTypeThreshold* add_type_thresholds();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >&
      type_thresholds() const;

  // int64 tx_threshold = 1;
  void clear_tx_threshold();
  static const int kTxThresholdFieldNumber = 1;
  ::google::protobuf::int64 tx_threshold() const;
  void set_tx_threshold(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.AccountThreshold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold > type_thresholds_;
  ::google::protobuf::int64 tx_threshold_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationIssueAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.OperationIssueAsset) */ {
 public:
  OperationIssueAsset();
  virtual ~OperationIssueAsset();

  OperationIssueAsset(const OperationIssueAsset& from);

  inline OperationIssueAsset& operator=(const OperationIssueAsset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationIssueAsset(OperationIssueAsset&& from) noexcept
    : OperationIssueAsset() {
    *this = ::std::move(from);
  }

  inline OperationIssueAsset& operator=(OperationIssueAsset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationIssueAsset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationIssueAsset* internal_default_instance() {
    return reinterpret_cast<const OperationIssueAsset*>(
               &_OperationIssueAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(OperationIssueAsset* other);
  friend void swap(OperationIssueAsset& a, OperationIssueAsset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationIssueAsset* New() const final {
    return CreateMaybeMessage<OperationIssueAsset>(NULL);
  }

  OperationIssueAsset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationIssueAsset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationIssueAsset& from);
  void MergeFrom(const OperationIssueAsset& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationIssueAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // int64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.OperationIssueAsset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationPayCoin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.OperationPayCoin) */ {
 public:
  OperationPayCoin();
  virtual ~OperationPayCoin();

  OperationPayCoin(const OperationPayCoin& from);

  inline OperationPayCoin& operator=(const OperationPayCoin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationPayCoin(OperationPayCoin&& from) noexcept
    : OperationPayCoin() {
    *this = ::std::move(from);
  }

  inline OperationPayCoin& operator=(OperationPayCoin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationPayCoin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationPayCoin* internal_default_instance() {
    return reinterpret_cast<const OperationPayCoin*>(
               &_OperationPayCoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(OperationPayCoin* other);
  friend void swap(OperationPayCoin& a, OperationPayCoin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationPayCoin* New() const final {
    return CreateMaybeMessage<OperationPayCoin>(NULL);
  }

  OperationPayCoin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationPayCoin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationPayCoin& from);
  void MergeFrom(const OperationPayCoin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationPayCoin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string dest_address = 1;
  void clear_dest_address();
  static const int kDestAddressFieldNumber = 1;
  const ::std::string& dest_address() const;
  void set_dest_address(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_address(::std::string&& value);
  #endif
  void set_dest_address(const char* value);
  void set_dest_address(const char* value, size_t size);
  ::std::string* mutable_dest_address();
  ::std::string* release_dest_address();
  void set_allocated_dest_address(::std::string* dest_address);

  // string input = 3;
  void clear_input();
  static const int kInputFieldNumber = 3;
  const ::std::string& input() const;
  void set_input(const ::std::string& value);
  #if LANG_CXX11
  void set_input(::std::string&& value);
  #endif
  void set_input(const char* value);
  void set_input(const char* value, size_t size);
  ::std::string* mutable_input();
  ::std::string* release_input();
  void set_allocated_input(::std::string* input);

  // int64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.OperationPayCoin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr dest_address_;
  ::google::protobuf::internal::ArenaStringPtr input_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationSetSignerWeight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.OperationSetSignerWeight) */ {
 public:
  OperationSetSignerWeight();
  virtual ~OperationSetSignerWeight();

  OperationSetSignerWeight(const OperationSetSignerWeight& from);

  inline OperationSetSignerWeight& operator=(const OperationSetSignerWeight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationSetSignerWeight(OperationSetSignerWeight&& from) noexcept
    : OperationSetSignerWeight() {
    *this = ::std::move(from);
  }

  inline OperationSetSignerWeight& operator=(OperationSetSignerWeight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSetSignerWeight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationSetSignerWeight* internal_default_instance() {
    return reinterpret_cast<const OperationSetSignerWeight*>(
               &_OperationSetSignerWeight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(OperationSetSignerWeight* other);
  friend void swap(OperationSetSignerWeight& a, OperationSetSignerWeight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationSetSignerWeight* New() const final {
    return CreateMaybeMessage<OperationSetSignerWeight>(NULL);
  }

  OperationSetSignerWeight* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationSetSignerWeight>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationSetSignerWeight& from);
  void MergeFrom(const OperationSetSignerWeight& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationSetSignerWeight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bumoProtocol.Signer signers = 2;
  int signers_size() const;
  void clear_signers();
  static const int kSignersFieldNumber = 2;
  ::bumoProtocol::Signer* mutable_signers(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >*
      mutable_signers();
  const ::bumoProtocol::Signer& signers(int index) const;
  ::bumoProtocol::Signer* add_signers();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >&
      signers() const;

  // int64 master_weight = 1;
  void clear_master_weight();
  static const int kMasterWeightFieldNumber = 1;
  ::google::protobuf::int64 master_weight() const;
  void set_master_weight(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.OperationSetSignerWeight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer > signers_;
  ::google::protobuf::int64 master_weight_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.OperationLog) */ {
 public:
  OperationLog();
  virtual ~OperationLog();

  OperationLog(const OperationLog& from);

  inline OperationLog& operator=(const OperationLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationLog(OperationLog&& from) noexcept
    : OperationLog() {
    *this = ::std::move(from);
  }

  inline OperationLog& operator=(OperationLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationLog* internal_default_instance() {
    return reinterpret_cast<const OperationLog*>(
               &_OperationLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(OperationLog* other);
  friend void swap(OperationLog& a, OperationLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationLog* New() const final {
    return CreateMaybeMessage<OperationLog>(NULL);
  }

  OperationLog* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationLog>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationLog& from);
  void MergeFrom(const OperationLog& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string datas = 2;
  int datas_size() const;
  void clear_datas();
  static const int kDatasFieldNumber = 2;
  const ::std::string& datas(int index) const;
  ::std::string* mutable_datas(int index);
  void set_datas(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_datas(int index, ::std::string&& value);
  #endif
  void set_datas(int index, const char* value);
  void set_datas(int index, const char* value, size_t size);
  ::std::string* add_datas();
  void add_datas(const ::std::string& value);
  #if LANG_CXX11
  void add_datas(::std::string&& value);
  #endif
  void add_datas(const char* value);
  void add_datas(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& datas() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_datas();

  // string topic = 1;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:bumoProtocol.OperationLog)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> datas_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationSetPrivilege : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.OperationSetPrivilege) */ {
 public:
  OperationSetPrivilege();
  virtual ~OperationSetPrivilege();

  OperationSetPrivilege(const OperationSetPrivilege& from);

  inline OperationSetPrivilege& operator=(const OperationSetPrivilege& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationSetPrivilege(OperationSetPrivilege&& from) noexcept
    : OperationSetPrivilege() {
    *this = ::std::move(from);
  }

  inline OperationSetPrivilege& operator=(OperationSetPrivilege&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSetPrivilege& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationSetPrivilege* internal_default_instance() {
    return reinterpret_cast<const OperationSetPrivilege*>(
               &_OperationSetPrivilege_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(OperationSetPrivilege* other);
  friend void swap(OperationSetPrivilege& a, OperationSetPrivilege& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationSetPrivilege* New() const final {
    return CreateMaybeMessage<OperationSetPrivilege>(NULL);
  }

  OperationSetPrivilege* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationSetPrivilege>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationSetPrivilege& from);
  void MergeFrom(const OperationSetPrivilege& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationSetPrivilege* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bumoProtocol.Signer signers = 2;
  int signers_size() const;
  void clear_signers();
  static const int kSignersFieldNumber = 2;
  ::bumoProtocol::Signer* mutable_signers(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >*
      mutable_signers();
  const ::bumoProtocol::Signer& signers(int index) const;
  ::bumoProtocol::Signer* add_signers();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >&
      signers() const;

  // repeated .bumoProtocol.OperationTypeThreshold type_thresholds = 4;
  int type_thresholds_size() const;
  void clear_type_thresholds();
  static const int kTypeThresholdsFieldNumber = 4;
  ::bumoProtocol::OperationTypeThreshold* mutable_type_thresholds(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >*
      mutable_type_thresholds();
  const ::bumoProtocol::OperationTypeThreshold& type_thresholds(int index) const;
  ::bumoProtocol::OperationTypeThreshold* add_type_thresholds();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >&
      type_thresholds() const;

  // string master_weight = 1;
  void clear_master_weight();
  static const int kMasterWeightFieldNumber = 1;
  const ::std::string& master_weight() const;
  void set_master_weight(const ::std::string& value);
  #if LANG_CXX11
  void set_master_weight(::std::string&& value);
  #endif
  void set_master_weight(const char* value);
  void set_master_weight(const char* value, size_t size);
  ::std::string* mutable_master_weight();
  ::std::string* release_master_weight();
  void set_allocated_master_weight(::std::string* master_weight);

  // string tx_threshold = 3;
  void clear_tx_threshold();
  static const int kTxThresholdFieldNumber = 3;
  const ::std::string& tx_threshold() const;
  void set_tx_threshold(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_threshold(::std::string&& value);
  #endif
  void set_tx_threshold(const char* value);
  void set_tx_threshold(const char* value, size_t size);
  ::std::string* mutable_tx_threshold();
  ::std::string* release_tx_threshold();
  void set_allocated_tx_threshold(::std::string* tx_threshold);

  // @@protoc_insertion_point(class_scope:bumoProtocol.OperationSetPrivilege)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer > signers_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold > type_thresholds_;
  ::google::protobuf::internal::ArenaStringPtr master_weight_;
  ::google::protobuf::internal::ArenaStringPtr tx_threshold_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Operation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.Operation) */ {
 public:
  Operation();
  virtual ~Operation();

  Operation(const Operation& from);

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(Operation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Operation* other);
  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Operation* New() const final {
    return CreateMaybeMessage<Operation>(NULL);
  }

  Operation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Operation_Type Type;
  static const Type UNKNOWN =
    Operation_Type_UNKNOWN;
  static const Type CREATE_ACCOUNT =
    Operation_Type_CREATE_ACCOUNT;
  static const Type ISSUE_ASSET =
    Operation_Type_ISSUE_ASSET;
  static const Type PAY_ASSET =
    Operation_Type_PAY_ASSET;
  static const Type SET_METADATA =
    Operation_Type_SET_METADATA;
  static const Type SET_SIGNER_WEIGHT =
    Operation_Type_SET_SIGNER_WEIGHT;
  static const Type SET_THRESHOLD =
    Operation_Type_SET_THRESHOLD;
  static const Type PAY_COIN =
    Operation_Type_PAY_COIN;
  static const Type LOG =
    Operation_Type_LOG;
  static const Type SET_PRIVILEGE =
    Operation_Type_SET_PRIVILEGE;
  static inline bool Type_IsValid(int value) {
    return Operation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Operation_Type_Type_MIN;
  static const Type Type_MAX =
    Operation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Operation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Operation_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Operation_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Operation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string source_address = 2;
  void clear_source_address();
  static const int kSourceAddressFieldNumber = 2;
  const ::std::string& source_address() const;
  void set_source_address(const ::std::string& value);
  #if LANG_CXX11
  void set_source_address(::std::string&& value);
  #endif
  void set_source_address(const char* value);
  void set_source_address(const char* value, size_t size);
  ::std::string* mutable_source_address();
  ::std::string* release_source_address();
  void set_allocated_source_address(::std::string* source_address);

  // bytes metadata = 3;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // .bumoProtocol.OperationCreateAccount create_account = 4;
  bool has_create_account() const;
  void clear_create_account();
  static const int kCreateAccountFieldNumber = 4;
  private:
  const ::bumoProtocol::OperationCreateAccount& _internal_create_account() const;
  public:
  const ::bumoProtocol::OperationCreateAccount& create_account() const;
  ::bumoProtocol::OperationCreateAccount* release_create_account();
  ::bumoProtocol::OperationCreateAccount* mutable_create_account();
  void set_allocated_create_account(::bumoProtocol::OperationCreateAccount* create_account);

  // .bumoProtocol.OperationIssueAsset issue_asset = 5;
  bool has_issue_asset() const;
  void clear_issue_asset();
  static const int kIssueAssetFieldNumber = 5;
  private:
  const ::bumoProtocol::OperationIssueAsset& _internal_issue_asset() const;
  public:
  const ::bumoProtocol::OperationIssueAsset& issue_asset() const;
  ::bumoProtocol::OperationIssueAsset* release_issue_asset();
  ::bumoProtocol::OperationIssueAsset* mutable_issue_asset();
  void set_allocated_issue_asset(::bumoProtocol::OperationIssueAsset* issue_asset);

  // .bumoProtocol.OperationPayAsset pay_asset = 6;
  bool has_pay_asset() const;
  void clear_pay_asset();
  static const int kPayAssetFieldNumber = 6;
  private:
  const ::bumoProtocol::OperationPayAsset& _internal_pay_asset() const;
  public:
  const ::bumoProtocol::OperationPayAsset& pay_asset() const;
  ::bumoProtocol::OperationPayAsset* release_pay_asset();
  ::bumoProtocol::OperationPayAsset* mutable_pay_asset();
  void set_allocated_pay_asset(::bumoProtocol::OperationPayAsset* pay_asset);

  // .bumoProtocol.OperationSetMetadata set_metadata = 7;
  bool has_set_metadata() const;
  void clear_set_metadata();
  static const int kSetMetadataFieldNumber = 7;
  private:
  const ::bumoProtocol::OperationSetMetadata& _internal_set_metadata() const;
  public:
  const ::bumoProtocol::OperationSetMetadata& set_metadata() const;
  ::bumoProtocol::OperationSetMetadata* release_set_metadata();
  ::bumoProtocol::OperationSetMetadata* mutable_set_metadata();
  void set_allocated_set_metadata(::bumoProtocol::OperationSetMetadata* set_metadata);

  // .bumoProtocol.OperationSetSignerWeight set_signer_weight = 8;
  bool has_set_signer_weight() const;
  void clear_set_signer_weight();
  static const int kSetSignerWeightFieldNumber = 8;
  private:
  const ::bumoProtocol::OperationSetSignerWeight& _internal_set_signer_weight() const;
  public:
  const ::bumoProtocol::OperationSetSignerWeight& set_signer_weight() const;
  ::bumoProtocol::OperationSetSignerWeight* release_set_signer_weight();
  ::bumoProtocol::OperationSetSignerWeight* mutable_set_signer_weight();
  void set_allocated_set_signer_weight(::bumoProtocol::OperationSetSignerWeight* set_signer_weight);

  // .bumoProtocol.OperationSetThreshold set_threshold = 9;
  bool has_set_threshold() const;
  void clear_set_threshold();
  static const int kSetThresholdFieldNumber = 9;
  private:
  const ::bumoProtocol::OperationSetThreshold& _internal_set_threshold() const;
  public:
  const ::bumoProtocol::OperationSetThreshold& set_threshold() const;
  ::bumoProtocol::OperationSetThreshold* release_set_threshold();
  ::bumoProtocol::OperationSetThreshold* mutable_set_threshold();
  void set_allocated_set_threshold(::bumoProtocol::OperationSetThreshold* set_threshold);

  // .bumoProtocol.OperationPayCoin pay_coin = 10;
  bool has_pay_coin() const;
  void clear_pay_coin();
  static const int kPayCoinFieldNumber = 10;
  private:
  const ::bumoProtocol::OperationPayCoin& _internal_pay_coin() const;
  public:
  const ::bumoProtocol::OperationPayCoin& pay_coin() const;
  ::bumoProtocol::OperationPayCoin* release_pay_coin();
  ::bumoProtocol::OperationPayCoin* mutable_pay_coin();
  void set_allocated_pay_coin(::bumoProtocol::OperationPayCoin* pay_coin);

  // .bumoProtocol.OperationLog log = 11;
  bool has_log() const;
  void clear_log();
  static const int kLogFieldNumber = 11;
  private:
  const ::bumoProtocol::OperationLog& _internal_log() const;
  public:
  const ::bumoProtocol::OperationLog& log() const;
  ::bumoProtocol::OperationLog* release_log();
  ::bumoProtocol::OperationLog* mutable_log();
  void set_allocated_log(::bumoProtocol::OperationLog* log);

  // .bumoProtocol.OperationSetPrivilege set_privilege = 12;
  bool has_set_privilege() const;
  void clear_set_privilege();
  static const int kSetPrivilegeFieldNumber = 12;
  private:
  const ::bumoProtocol::OperationSetPrivilege& _internal_set_privilege() const;
  public:
  const ::bumoProtocol::OperationSetPrivilege& set_privilege() const;
  ::bumoProtocol::OperationSetPrivilege* release_set_privilege();
  ::bumoProtocol::OperationSetPrivilege* mutable_set_privilege();
  void set_allocated_set_privilege(::bumoProtocol::OperationSetPrivilege* set_privilege);

  // .bumoProtocol.Operation.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::bumoProtocol::Operation_Type type() const;
  void set_type(::bumoProtocol::Operation_Type value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.Operation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr source_address_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::bumoProtocol::OperationCreateAccount* create_account_;
  ::bumoProtocol::OperationIssueAsset* issue_asset_;
  ::bumoProtocol::OperationPayAsset* pay_asset_;
  ::bumoProtocol::OperationSetMetadata* set_metadata_;
  ::bumoProtocol::OperationSetSignerWeight* set_signer_weight_;
  ::bumoProtocol::OperationSetThreshold* set_threshold_;
  ::bumoProtocol::OperationPayCoin* pay_coin_;
  ::bumoProtocol::OperationLog* log_;
  ::bumoProtocol::OperationSetPrivilege* set_privilege_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationSetThreshold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.OperationSetThreshold) */ {
 public:
  OperationSetThreshold();
  virtual ~OperationSetThreshold();

  OperationSetThreshold(const OperationSetThreshold& from);

  inline OperationSetThreshold& operator=(const OperationSetThreshold& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationSetThreshold(OperationSetThreshold&& from) noexcept
    : OperationSetThreshold() {
    *this = ::std::move(from);
  }

  inline OperationSetThreshold& operator=(OperationSetThreshold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSetThreshold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationSetThreshold* internal_default_instance() {
    return reinterpret_cast<const OperationSetThreshold*>(
               &_OperationSetThreshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(OperationSetThreshold* other);
  friend void swap(OperationSetThreshold& a, OperationSetThreshold& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationSetThreshold* New() const final {
    return CreateMaybeMessage<OperationSetThreshold>(NULL);
  }

  OperationSetThreshold* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationSetThreshold>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationSetThreshold& from);
  void MergeFrom(const OperationSetThreshold& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationSetThreshold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bumoProtocol.OperationTypeThreshold type_thresholds = 2;
  int type_thresholds_size() const;
  void clear_type_thresholds();
  static const int kTypeThresholdsFieldNumber = 2;
  ::bumoProtocol::OperationTypeThreshold* mutable_type_thresholds(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >*
      mutable_type_thresholds();
  const ::bumoProtocol::OperationTypeThreshold& type_thresholds(int index) const;
  ::bumoProtocol::OperationTypeThreshold* add_type_thresholds();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >&
      type_thresholds() const;

  // int64 tx_threshold = 1;
  void clear_tx_threshold();
  static const int kTxThresholdFieldNumber = 1;
  ::google::protobuf::int64 tx_threshold() const;
  void set_tx_threshold(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.OperationSetThreshold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold > type_thresholds_;
  ::google::protobuf::int64 tx_threshold_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(NULL);
  }

  Transaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Transaction_Limit Limit;
  static const Limit UNKNOWN =
    Transaction_Limit_UNKNOWN;
  static const Limit OPERATIONS =
    Transaction_Limit_OPERATIONS;
  static inline bool Limit_IsValid(int value) {
    return Transaction_Limit_IsValid(value);
  }
  static const Limit Limit_MIN =
    Transaction_Limit_Limit_MIN;
  static const Limit Limit_MAX =
    Transaction_Limit_Limit_MAX;
  static const int Limit_ARRAYSIZE =
    Transaction_Limit_Limit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Limit_descriptor() {
    return Transaction_Limit_descriptor();
  }
  static inline const ::std::string& Limit_Name(Limit value) {
    return Transaction_Limit_Name(value);
  }
  static inline bool Limit_Parse(const ::std::string& name,
      Limit* value) {
    return Transaction_Limit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .bumoProtocol.Operation operations = 7;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 7;
  ::bumoProtocol::Operation* mutable_operations(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Operation >*
      mutable_operations();
  const ::bumoProtocol::Operation& operations(int index) const;
  ::bumoProtocol::Operation* add_operations();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Operation >&
      operations() const;

  // string source_address = 1;
  void clear_source_address();
  static const int kSourceAddressFieldNumber = 1;
  const ::std::string& source_address() const;
  void set_source_address(const ::std::string& value);
  #if LANG_CXX11
  void set_source_address(::std::string&& value);
  #endif
  void set_source_address(const char* value);
  void set_source_address(const char* value, size_t size);
  ::std::string* mutable_source_address();
  ::std::string* release_source_address();
  void set_allocated_source_address(::std::string* source_address);

  // bytes metadata = 6;
  void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // int64 nonce = 2;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  ::google::protobuf::int64 nonce() const;
  void set_nonce(::google::protobuf::int64 value);

  // int64 fee_limit = 3;
  void clear_fee_limit();
  static const int kFeeLimitFieldNumber = 3;
  ::google::protobuf::int64 fee_limit() const;
  void set_fee_limit(::google::protobuf::int64 value);

  // int64 gas_price = 4;
  void clear_gas_price();
  static const int kGasPriceFieldNumber = 4;
  ::google::protobuf::int64 gas_price() const;
  void set_gas_price(::google::protobuf::int64 value);

  // int64 ceil_ledger_seq = 5;
  void clear_ceil_ledger_seq();
  static const int kCeilLedgerSeqFieldNumber = 5;
  ::google::protobuf::int64 ceil_ledger_seq() const;
  void set_ceil_ledger_seq(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.Transaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Operation > operations_;
  ::google::protobuf::internal::ArenaStringPtr source_address_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::int64 nonce_;
  ::google::protobuf::int64 fee_limit_;
  ::google::protobuf::int64 gas_price_;
  ::google::protobuf::int64 ceil_ledger_seq_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.Signer) */ {
 public:
  Signer();
  virtual ~Signer();

  Signer(const Signer& from);

  inline Signer& operator=(const Signer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signer(Signer&& from) noexcept
    : Signer() {
    *this = ::std::move(from);
  }

  inline Signer& operator=(Signer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signer* internal_default_instance() {
    return reinterpret_cast<const Signer*>(
               &_Signer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Signer* other);
  friend void swap(Signer& a, Signer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signer* New() const final {
    return CreateMaybeMessage<Signer>(NULL);
  }

  Signer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signer& from);
  void MergeFrom(const Signer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Signer_Limit Limit;
  static const Limit SIGNER_NONE =
    Signer_Limit_SIGNER_NONE;
  static const Limit SIGNER =
    Signer_Limit_SIGNER;
  static inline bool Limit_IsValid(int value) {
    return Signer_Limit_IsValid(value);
  }
  static const Limit Limit_MIN =
    Signer_Limit_Limit_MIN;
  static const Limit Limit_MAX =
    Signer_Limit_Limit_MAX;
  static const int Limit_ARRAYSIZE =
    Signer_Limit_Limit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Limit_descriptor() {
    return Signer_Limit_descriptor();
  }
  static inline const ::std::string& Limit_Name(Limit value) {
    return Signer_Limit_Name(value);
  }
  static inline bool Limit_Parse(const ::std::string& name,
      Limit* value) {
    return Signer_Limit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // int64 weight = 2;
  void clear_weight();
  static const int kWeightFieldNumber = 2;
  ::google::protobuf::int64 weight() const;
  void set_weight(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.Signer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::int64 weight_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Trigger_OperationTrigger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.Trigger.OperationTrigger) */ {
 public:
  Trigger_OperationTrigger();
  virtual ~Trigger_OperationTrigger();

  Trigger_OperationTrigger(const Trigger_OperationTrigger& from);

  inline Trigger_OperationTrigger& operator=(const Trigger_OperationTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trigger_OperationTrigger(Trigger_OperationTrigger&& from) noexcept
    : Trigger_OperationTrigger() {
    *this = ::std::move(from);
  }

  inline Trigger_OperationTrigger& operator=(Trigger_OperationTrigger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trigger_OperationTrigger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trigger_OperationTrigger* internal_default_instance() {
    return reinterpret_cast<const Trigger_OperationTrigger*>(
               &_Trigger_OperationTrigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Trigger_OperationTrigger* other);
  friend void swap(Trigger_OperationTrigger& a, Trigger_OperationTrigger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trigger_OperationTrigger* New() const final {
    return CreateMaybeMessage<Trigger_OperationTrigger>(NULL);
  }

  Trigger_OperationTrigger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Trigger_OperationTrigger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Trigger_OperationTrigger& from);
  void MergeFrom(const Trigger_OperationTrigger& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trigger_OperationTrigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // int64 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int64 index() const;
  void set_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.Trigger.OperationTrigger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::int64 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Trigger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.Trigger) */ {
 public:
  Trigger();
  virtual ~Trigger();

  Trigger(const Trigger& from);

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trigger(Trigger&& from) noexcept
    : Trigger() {
    *this = ::std::move(from);
  }

  inline Trigger& operator=(Trigger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trigger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trigger* internal_default_instance() {
    return reinterpret_cast<const Trigger*>(
               &_Trigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(Trigger* other);
  friend void swap(Trigger& a, Trigger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trigger* New() const final {
    return CreateMaybeMessage<Trigger>(NULL);
  }

  Trigger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Trigger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Trigger_OperationTrigger OperationTrigger;

  typedef Trigger_TransactionType TransactionType;
  static const TransactionType NORMAL_TRANSACTION =
    Trigger_TransactionType_NORMAL_TRANSACTION;
  static const TransactionType CONTRACT_TRANSACTION =
    Trigger_TransactionType_CONTRACT_TRANSACTION;
  static inline bool TransactionType_IsValid(int value) {
    return Trigger_TransactionType_IsValid(value);
  }
  static const TransactionType TransactionType_MIN =
    Trigger_TransactionType_TransactionType_MIN;
  static const TransactionType TransactionType_MAX =
    Trigger_TransactionType_TransactionType_MAX;
  static const int TransactionType_ARRAYSIZE =
    Trigger_TransactionType_TransactionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransactionType_descriptor() {
    return Trigger_TransactionType_descriptor();
  }
  static inline const ::std::string& TransactionType_Name(TransactionType value) {
    return Trigger_TransactionType_Name(value);
  }
  static inline bool TransactionType_Parse(const ::std::string& name,
      TransactionType* value) {
    return Trigger_TransactionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .bumoProtocol.Trigger.OperationTrigger transaction = 3;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 3;
  private:
  const ::bumoProtocol::Trigger_OperationTrigger& _internal_transaction() const;
  public:
  const ::bumoProtocol::Trigger_OperationTrigger& transaction() const;
  ::bumoProtocol::Trigger_OperationTrigger* release_transaction();
  ::bumoProtocol::Trigger_OperationTrigger* mutable_transaction();
  void set_allocated_transaction(::bumoProtocol::Trigger_OperationTrigger* transaction);

  // int64 ledger_seq = 2;
  void clear_ledger_seq();
  static const int kLedgerSeqFieldNumber = 2;
  ::google::protobuf::int64 ledger_seq() const;
  void set_ledger_seq(::google::protobuf::int64 value);

  // .bumoProtocol.Trigger.TransactionType transaction_type = 1;
  void clear_transaction_type();
  static const int kTransactionTypeFieldNumber = 1;
  ::bumoProtocol::Trigger_TransactionType transaction_type() const;
  void set_transaction_type(::bumoProtocol::Trigger_TransactionType value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.Trigger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bumoProtocol::Trigger_OperationTrigger* transaction_;
  ::google::protobuf::int64 ledger_seq_;
  int transaction_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionEnv : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.TransactionEnv) */ {
 public:
  TransactionEnv();
  virtual ~TransactionEnv();

  TransactionEnv(const TransactionEnv& from);

  inline TransactionEnv& operator=(const TransactionEnv& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionEnv(TransactionEnv&& from) noexcept
    : TransactionEnv() {
    *this = ::std::move(from);
  }

  inline TransactionEnv& operator=(TransactionEnv&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionEnv& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionEnv* internal_default_instance() {
    return reinterpret_cast<const TransactionEnv*>(
               &_TransactionEnv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(TransactionEnv* other);
  friend void swap(TransactionEnv& a, TransactionEnv& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionEnv* New() const final {
    return CreateMaybeMessage<TransactionEnv>(NULL);
  }

  TransactionEnv* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransactionEnv>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransactionEnv& from);
  void MergeFrom(const TransactionEnv& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionEnv* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bumoProtocol.Signature signatures = 2;
  int signatures_size() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 2;
  ::bumoProtocol::Signature* mutable_signatures(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signature >*
      mutable_signatures();
  const ::bumoProtocol::Signature& signatures(int index) const;
  ::bumoProtocol::Signature* add_signatures();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signature >&
      signatures() const;

  // .bumoProtocol.Transaction transaction = 1;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 1;
  private:
  const ::bumoProtocol::Transaction& _internal_transaction() const;
  public:
  const ::bumoProtocol::Transaction& transaction() const;
  ::bumoProtocol::Transaction* release_transaction();
  ::bumoProtocol::Transaction* mutable_transaction();
  void set_allocated_transaction(::bumoProtocol::Transaction* transaction);

  // .bumoProtocol.Trigger trigger = 3;
  bool has_trigger() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 3;
  private:
  const ::bumoProtocol::Trigger& _internal_trigger() const;
  public:
  const ::bumoProtocol::Trigger& trigger() const;
  ::bumoProtocol::Trigger* release_trigger();
  ::bumoProtocol::Trigger* mutable_trigger();
  void set_allocated_trigger(::bumoProtocol::Trigger* trigger);

  // @@protoc_insertion_point(class_scope:bumoProtocol.TransactionEnv)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signature > signatures_;
  ::bumoProtocol::Transaction* transaction_;
  ::bumoProtocol::Trigger* trigger_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionEnvStore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.TransactionEnvStore) */ {
 public:
  TransactionEnvStore();
  virtual ~TransactionEnvStore();

  TransactionEnvStore(const TransactionEnvStore& from);

  inline TransactionEnvStore& operator=(const TransactionEnvStore& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionEnvStore(TransactionEnvStore&& from) noexcept
    : TransactionEnvStore() {
    *this = ::std::move(from);
  }

  inline TransactionEnvStore& operator=(TransactionEnvStore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionEnvStore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionEnvStore* internal_default_instance() {
    return reinterpret_cast<const TransactionEnvStore*>(
               &_TransactionEnvStore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(TransactionEnvStore* other);
  friend void swap(TransactionEnvStore& a, TransactionEnvStore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionEnvStore* New() const final {
    return CreateMaybeMessage<TransactionEnvStore>(NULL);
  }

  TransactionEnvStore* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransactionEnvStore>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransactionEnvStore& from);
  void MergeFrom(const TransactionEnvStore& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionEnvStore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_desc = 3;
  void clear_error_desc();
  static const int kErrorDescFieldNumber = 3;
  const ::std::string& error_desc() const;
  void set_error_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_error_desc(::std::string&& value);
  #endif
  void set_error_desc(const char* value);
  void set_error_desc(const char* value, size_t size);
  ::std::string* mutable_error_desc();
  ::std::string* release_error_desc();
  void set_allocated_error_desc(::std::string* error_desc);

  // bytes hash = 6;
  void clear_hash();
  static const int kHashFieldNumber = 6;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .bumoProtocol.TransactionEnv transaction_env = 1;
  bool has_transaction_env() const;
  void clear_transaction_env();
  static const int kTransactionEnvFieldNumber = 1;
  private:
  const ::bumoProtocol::TransactionEnv& _internal_transaction_env() const;
  public:
  const ::bumoProtocol::TransactionEnv& transaction_env() const;
  ::bumoProtocol::TransactionEnv* release_transaction_env();
  ::bumoProtocol::TransactionEnv* mutable_transaction_env();
  void set_allocated_transaction_env(::bumoProtocol::TransactionEnv* transaction_env);

  // int64 ledger_seq = 4;
  void clear_ledger_seq();
  static const int kLedgerSeqFieldNumber = 4;
  ::google::protobuf::int64 ledger_seq() const;
  void set_ledger_seq(::google::protobuf::int64 value);

  // int64 close_time = 5;
  void clear_close_time();
  static const int kCloseTimeFieldNumber = 5;
  ::google::protobuf::int64 close_time() const;
  void set_close_time(::google::protobuf::int64 value);

  // int64 actual_fee = 7;
  void clear_actual_fee();
  static const int kActualFeeFieldNumber = 7;
  ::google::protobuf::int64 actual_fee() const;
  void set_actual_fee(::google::protobuf::int64 value);

  // int32 error_code = 2;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.TransactionEnvStore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_desc_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::bumoProtocol::TransactionEnv* transaction_env_;
  ::google::protobuf::int64 ledger_seq_;
  ::google::protobuf::int64 close_time_;
  ::google::protobuf::int64 actual_fee_;
  ::google::protobuf::int32 error_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionEnvSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.TransactionEnvSet) */ {
 public:
  TransactionEnvSet();
  virtual ~TransactionEnvSet();

  TransactionEnvSet(const TransactionEnvSet& from);

  inline TransactionEnvSet& operator=(const TransactionEnvSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionEnvSet(TransactionEnvSet&& from) noexcept
    : TransactionEnvSet() {
    *this = ::std::move(from);
  }

  inline TransactionEnvSet& operator=(TransactionEnvSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionEnvSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionEnvSet* internal_default_instance() {
    return reinterpret_cast<const TransactionEnvSet*>(
               &_TransactionEnvSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(TransactionEnvSet* other);
  friend void swap(TransactionEnvSet& a, TransactionEnvSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionEnvSet* New() const final {
    return CreateMaybeMessage<TransactionEnvSet>(NULL);
  }

  TransactionEnvSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransactionEnvSet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransactionEnvSet& from);
  void MergeFrom(const TransactionEnvSet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionEnvSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bumoProtocol.TransactionEnv txs = 2;
  int txs_size() const;
  void clear_txs();
  static const int kTxsFieldNumber = 2;
  ::bumoProtocol::TransactionEnv* mutable_txs(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::TransactionEnv >*
      mutable_txs();
  const ::bumoProtocol::TransactionEnv& txs(int index) const;
  ::bumoProtocol::TransactionEnv* add_txs();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::TransactionEnv >&
      txs() const;

  // @@protoc_insertion_point(class_scope:bumoProtocol.TransactionEnvSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::TransactionEnv > txs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConsensusValueValidation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.ConsensusValueValidation) */ {
 public:
  ConsensusValueValidation();
  virtual ~ConsensusValueValidation();

  ConsensusValueValidation(const ConsensusValueValidation& from);

  inline ConsensusValueValidation& operator=(const ConsensusValueValidation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConsensusValueValidation(ConsensusValueValidation&& from) noexcept
    : ConsensusValueValidation() {
    *this = ::std::move(from);
  }

  inline ConsensusValueValidation& operator=(ConsensusValueValidation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsensusValueValidation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConsensusValueValidation* internal_default_instance() {
    return reinterpret_cast<const ConsensusValueValidation*>(
               &_ConsensusValueValidation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(ConsensusValueValidation* other);
  friend void swap(ConsensusValueValidation& a, ConsensusValueValidation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConsensusValueValidation* New() const final {
    return CreateMaybeMessage<ConsensusValueValidation>(NULL);
  }

  ConsensusValueValidation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConsensusValueValidation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConsensusValueValidation& from);
  void MergeFrom(const ConsensusValueValidation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsensusValueValidation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 expire_tx_ids = 1;
  int expire_tx_ids_size() const;
  void clear_expire_tx_ids();
  static const int kExpireTxIdsFieldNumber = 1;
  ::google::protobuf::int32 expire_tx_ids(int index) const;
  void set_expire_tx_ids(int index, ::google::protobuf::int32 value);
  void add_expire_tx_ids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      expire_tx_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_expire_tx_ids();

  // repeated int32 error_tx_ids = 2;
  int error_tx_ids_size() const;
  void clear_error_tx_ids();
  static const int kErrorTxIdsFieldNumber = 2;
  ::google::protobuf::int32 error_tx_ids(int index) const;
  void set_error_tx_ids(int index, ::google::protobuf::int32 value);
  void add_error_tx_ids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      error_tx_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_error_tx_ids();

  // @@protoc_insertion_point(class_scope:bumoProtocol.ConsensusValueValidation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > expire_tx_ids_;
  mutable int _expire_tx_ids_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > error_tx_ids_;
  mutable int _error_tx_ids_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConsensusValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.ConsensusValue) */ {
 public:
  ConsensusValue();
  virtual ~ConsensusValue();

  ConsensusValue(const ConsensusValue& from);

  inline ConsensusValue& operator=(const ConsensusValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConsensusValue(ConsensusValue&& from) noexcept
    : ConsensusValue() {
    *this = ::std::move(from);
  }

  inline ConsensusValue& operator=(ConsensusValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsensusValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConsensusValue* internal_default_instance() {
    return reinterpret_cast<const ConsensusValue*>(
               &_ConsensusValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ConsensusValue* other);
  friend void swap(ConsensusValue& a, ConsensusValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConsensusValue* New() const final {
    return CreateMaybeMessage<ConsensusValue>(NULL);
  }

  ConsensusValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConsensusValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConsensusValue& from);
  void MergeFrom(const ConsensusValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsensusValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes previous_proof = 3;
  void clear_previous_proof();
  static const int kPreviousProofFieldNumber = 3;
  const ::std::string& previous_proof() const;
  void set_previous_proof(const ::std::string& value);
  #if LANG_CXX11
  void set_previous_proof(::std::string&& value);
  #endif
  void set_previous_proof(const char* value);
  void set_previous_proof(const void* value, size_t size);
  ::std::string* mutable_previous_proof();
  ::std::string* release_previous_proof();
  void set_allocated_previous_proof(::std::string* previous_proof);

  // bytes previous_ledger_hash = 5;
  void clear_previous_ledger_hash();
  static const int kPreviousLedgerHashFieldNumber = 5;
  const ::std::string& previous_ledger_hash() const;
  void set_previous_ledger_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_previous_ledger_hash(::std::string&& value);
  #endif
  void set_previous_ledger_hash(const char* value);
  void set_previous_ledger_hash(const void* value, size_t size);
  ::std::string* mutable_previous_ledger_hash();
  ::std::string* release_previous_ledger_hash();
  void set_allocated_previous_ledger_hash(::std::string* previous_ledger_hash);

  // .bumoProtocol.TransactionEnvSet txset = 1;
  bool has_txset() const;
  void clear_txset();
  static const int kTxsetFieldNumber = 1;
  private:
  const ::bumoProtocol::TransactionEnvSet& _internal_txset() const;
  public:
  const ::bumoProtocol::TransactionEnvSet& txset() const;
  ::bumoProtocol::TransactionEnvSet* release_txset();
  ::bumoProtocol::TransactionEnvSet* mutable_txset();
  void set_allocated_txset(::bumoProtocol::TransactionEnvSet* txset);

  // .bumoProtocol.LedgerUpgrade ledger_upgrade = 6;
  bool has_ledger_upgrade() const;
  void clear_ledger_upgrade();
  static const int kLedgerUpgradeFieldNumber = 6;
  private:
  const ::bumoProtocol::LedgerUpgrade& _internal_ledger_upgrade() const;
  public:
  const ::bumoProtocol::LedgerUpgrade& ledger_upgrade() const;
  ::bumoProtocol::LedgerUpgrade* release_ledger_upgrade();
  ::bumoProtocol::LedgerUpgrade* mutable_ledger_upgrade();
  void set_allocated_ledger_upgrade(::bumoProtocol::LedgerUpgrade* ledger_upgrade);

  // .bumoProtocol.ConsensusValueValidation validation = 7;
  bool has_validation() const;
  void clear_validation();
  static const int kValidationFieldNumber = 7;
  private:
  const ::bumoProtocol::ConsensusValueValidation& _internal_validation() const;
  public:
  const ::bumoProtocol::ConsensusValueValidation& validation() const;
  ::bumoProtocol::ConsensusValueValidation* release_validation();
  ::bumoProtocol::ConsensusValueValidation* mutable_validation();
  void set_allocated_validation(::bumoProtocol::ConsensusValueValidation* validation);

  // int64 close_time = 2;
  void clear_close_time();
  static const int kCloseTimeFieldNumber = 2;
  ::google::protobuf::int64 close_time() const;
  void set_close_time(::google::protobuf::int64 value);

  // int64 ledger_seq = 4;
  void clear_ledger_seq();
  static const int kLedgerSeqFieldNumber = 4;
  ::google::protobuf::int64 ledger_seq() const;
  void set_ledger_seq(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.ConsensusValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr previous_proof_;
  ::google::protobuf::internal::ArenaStringPtr previous_ledger_hash_;
  ::bumoProtocol::TransactionEnvSet* txset_;
  ::bumoProtocol::LedgerUpgrade* ledger_upgrade_;
  ::bumoProtocol::ConsensusValueValidation* validation_;
  ::google::protobuf::int64 close_time_;
  ::google::protobuf::int64 ledger_seq_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Contract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.Contract) */ {
 public:
  Contract();
  virtual ~Contract();

  Contract(const Contract& from);

  inline Contract& operator=(const Contract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Contract(Contract&& from) noexcept
    : Contract() {
    *this = ::std::move(from);
  }

  inline Contract& operator=(Contract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Contract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Contract* internal_default_instance() {
    return reinterpret_cast<const Contract*>(
               &_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(Contract* other);
  friend void swap(Contract& a, Contract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Contract* New() const final {
    return CreateMaybeMessage<Contract>(NULL);
  }

  Contract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Contract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Contract& from);
  void MergeFrom(const Contract& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Contract_ContractType ContractType;
  static const ContractType JAVASCRIPT =
    Contract_ContractType_JAVASCRIPT;
  static inline bool ContractType_IsValid(int value) {
    return Contract_ContractType_IsValid(value);
  }
  static const ContractType ContractType_MIN =
    Contract_ContractType_ContractType_MIN;
  static const ContractType ContractType_MAX =
    Contract_ContractType_ContractType_MAX;
  static const int ContractType_ARRAYSIZE =
    Contract_ContractType_ContractType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ContractType_descriptor() {
    return Contract_ContractType_descriptor();
  }
  static inline const ::std::string& ContractType_Name(ContractType value) {
    return Contract_ContractType_Name(value);
  }
  static inline bool ContractType_Parse(const ::std::string& name,
      ContractType* value) {
    return Contract_ContractType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string payload = 2;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const char* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // .bumoProtocol.Contract.ContractType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::bumoProtocol::Contract_ContractType type() const;
  void set_type(::bumoProtocol::Contract_ContractType value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.Contract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationCreateAccount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.OperationCreateAccount) */ {
 public:
  OperationCreateAccount();
  virtual ~OperationCreateAccount();

  OperationCreateAccount(const OperationCreateAccount& from);

  inline OperationCreateAccount& operator=(const OperationCreateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationCreateAccount(OperationCreateAccount&& from) noexcept
    : OperationCreateAccount() {
    *this = ::std::move(from);
  }

  inline OperationCreateAccount& operator=(OperationCreateAccount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationCreateAccount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationCreateAccount* internal_default_instance() {
    return reinterpret_cast<const OperationCreateAccount*>(
               &_OperationCreateAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(OperationCreateAccount* other);
  friend void swap(OperationCreateAccount& a, OperationCreateAccount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationCreateAccount* New() const final {
    return CreateMaybeMessage<OperationCreateAccount>(NULL);
  }

  OperationCreateAccount* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationCreateAccount>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationCreateAccount& from);
  void MergeFrom(const OperationCreateAccount& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationCreateAccount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bumoProtocol.KeyPair metadatas = 4;
  int metadatas_size() const;
  void clear_metadatas();
  static const int kMetadatasFieldNumber = 4;
  ::bumoProtocol::KeyPair* mutable_metadatas(int index);
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::KeyPair >*
      mutable_metadatas();
  const ::bumoProtocol::KeyPair& metadatas(int index) const;
  ::bumoProtocol::KeyPair* add_metadatas();
  const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::KeyPair >&
      metadatas() const;

  // string dest_address = 1;
  void clear_dest_address();
  static const int kDestAddressFieldNumber = 1;
  const ::std::string& dest_address() const;
  void set_dest_address(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_address(::std::string&& value);
  #endif
  void set_dest_address(const char* value);
  void set_dest_address(const char* value, size_t size);
  ::std::string* mutable_dest_address();
  ::std::string* release_dest_address();
  void set_allocated_dest_address(::std::string* dest_address);

  // string init_input = 6;
  void clear_init_input();
  static const int kInitInputFieldNumber = 6;
  const ::std::string& init_input() const;
  void set_init_input(const ::std::string& value);
  #if LANG_CXX11
  void set_init_input(::std::string&& value);
  #endif
  void set_init_input(const char* value);
  void set_init_input(const char* value, size_t size);
  ::std::string* mutable_init_input();
  ::std::string* release_init_input();
  void set_allocated_init_input(::std::string* init_input);

  // .bumoProtocol.Contract contract = 2;
  bool has_contract() const;
  void clear_contract();
  static const int kContractFieldNumber = 2;
  private:
  const ::bumoProtocol::Contract& _internal_contract() const;
  public:
  const ::bumoProtocol::Contract& contract() const;
  ::bumoProtocol::Contract* release_contract();
  ::bumoProtocol::Contract* mutable_contract();
  void set_allocated_contract(::bumoProtocol::Contract* contract);

  // .bumoProtocol.AccountPrivilege priv = 3;
  bool has_priv() const;
  void clear_priv();
  static const int kPrivFieldNumber = 3;
  private:
  const ::bumoProtocol::AccountPrivilege& _internal_priv() const;
  public:
  const ::bumoProtocol::AccountPrivilege& priv() const;
  ::bumoProtocol::AccountPrivilege* release_priv();
  ::bumoProtocol::AccountPrivilege* mutable_priv();
  void set_allocated_priv(::bumoProtocol::AccountPrivilege* priv);

  // int64 init_balance = 5;
  void clear_init_balance();
  static const int kInitBalanceFieldNumber = 5;
  ::google::protobuf::int64 init_balance() const;
  void set_init_balance(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.OperationCreateAccount)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bumoProtocol::KeyPair > metadatas_;
  ::google::protobuf::internal::ArenaStringPtr dest_address_;
  ::google::protobuf::internal::ArenaStringPtr init_input_;
  ::bumoProtocol::Contract* contract_;
  ::bumoProtocol::AccountPrivilege* priv_;
  ::google::protobuf::int64 init_balance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationSetMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bumoProtocol.OperationSetMetadata) */ {
 public:
  OperationSetMetadata();
  virtual ~OperationSetMetadata();

  OperationSetMetadata(const OperationSetMetadata& from);

  inline OperationSetMetadata& operator=(const OperationSetMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationSetMetadata(OperationSetMetadata&& from) noexcept
    : OperationSetMetadata() {
    *this = ::std::move(from);
  }

  inline OperationSetMetadata& operator=(OperationSetMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSetMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationSetMetadata* internal_default_instance() {
    return reinterpret_cast<const OperationSetMetadata*>(
               &_OperationSetMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(OperationSetMetadata* other);
  friend void swap(OperationSetMetadata& a, OperationSetMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationSetMetadata* New() const final {
    return CreateMaybeMessage<OperationSetMetadata>(NULL);
  }

  OperationSetMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperationSetMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperationSetMetadata& from);
  void MergeFrom(const OperationSetMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationSetMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // int64 version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // bool delete_flag = 4;
  void clear_delete_flag();
  static const int kDeleteFlagFieldNumber = 4;
  bool delete_flag() const;
  void set_delete_flag(bool value);

  // @@protoc_insertion_point(class_scope:bumoProtocol.OperationSetMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int64 version_;
  bool delete_flag_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chain_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Account

// string address = 1;
inline void Account::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::address() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Account.address)
  return address_.GetNoArena();
}
inline void Account::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.Account.address)
}
#if LANG_CXX11
inline void Account::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.Account.address)
}
#endif
inline void Account::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.Account.address)
}
inline void Account::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.Account.address)
}
inline ::std::string* Account::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Account.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_address() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Account.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Account.address)
}

// int64 nonce = 2;
inline void Account::clear_nonce() {
  nonce_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::nonce() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Account.nonce)
  return nonce_;
}
inline void Account::set_nonce(::google::protobuf::int64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Account.nonce)
}

// .bumoProtocol.AccountPrivilege priv = 3;
inline bool Account::has_priv() const {
  return this != internal_default_instance() && priv_ != NULL;
}
inline void Account::clear_priv() {
  if (GetArenaNoVirtual() == NULL && priv_ != NULL) {
    delete priv_;
  }
  priv_ = NULL;
}
inline const ::bumoProtocol::AccountPrivilege& Account::_internal_priv() const {
  return *priv_;
}
inline const ::bumoProtocol::AccountPrivilege& Account::priv() const {
  const ::bumoProtocol::AccountPrivilege* p = priv_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Account.priv)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::AccountPrivilege*>(
      &::bumoProtocol::_AccountPrivilege_default_instance_);
}
inline ::bumoProtocol::AccountPrivilege* Account::release_priv() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Account.priv)
  
  ::bumoProtocol::AccountPrivilege* temp = priv_;
  priv_ = NULL;
  return temp;
}
inline ::bumoProtocol::AccountPrivilege* Account::mutable_priv() {
  
  if (priv_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::AccountPrivilege>(GetArenaNoVirtual());
    priv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Account.priv)
  return priv_;
}
inline void Account::set_allocated_priv(::bumoProtocol::AccountPrivilege* priv) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete priv_;
  }
  if (priv) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      priv = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, priv, submessage_arena);
    }
    
  } else {
    
  }
  priv_ = priv;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Account.priv)
}

// bytes metadatas_hash = 4;
inline void Account::clear_metadatas_hash() {
  metadatas_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::metadatas_hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Account.metadatas_hash)
  return metadatas_hash_.GetNoArena();
}
inline void Account::set_metadatas_hash(const ::std::string& value) {
  
  metadatas_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.Account.metadatas_hash)
}
#if LANG_CXX11
inline void Account::set_metadatas_hash(::std::string&& value) {
  
  metadatas_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.Account.metadatas_hash)
}
#endif
inline void Account::set_metadatas_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadatas_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.Account.metadatas_hash)
}
inline void Account::set_metadatas_hash(const void* value, size_t size) {
  
  metadatas_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.Account.metadatas_hash)
}
inline ::std::string* Account::mutable_metadatas_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Account.metadatas_hash)
  return metadatas_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_metadatas_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Account.metadatas_hash)
  
  return metadatas_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_metadatas_hash(::std::string* metadatas_hash) {
  if (metadatas_hash != NULL) {
    
  } else {
    
  }
  metadatas_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadatas_hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Account.metadatas_hash)
}

// bytes assets_hash = 5;
inline void Account::clear_assets_hash() {
  assets_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::assets_hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Account.assets_hash)
  return assets_hash_.GetNoArena();
}
inline void Account::set_assets_hash(const ::std::string& value) {
  
  assets_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.Account.assets_hash)
}
#if LANG_CXX11
inline void Account::set_assets_hash(::std::string&& value) {
  
  assets_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.Account.assets_hash)
}
#endif
inline void Account::set_assets_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  assets_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.Account.assets_hash)
}
inline void Account::set_assets_hash(const void* value, size_t size) {
  
  assets_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.Account.assets_hash)
}
inline ::std::string* Account::mutable_assets_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Account.assets_hash)
  return assets_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_assets_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Account.assets_hash)
  
  return assets_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_assets_hash(::std::string* assets_hash) {
  if (assets_hash != NULL) {
    
  } else {
    
  }
  assets_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), assets_hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Account.assets_hash)
}

// .bumoProtocol.Contract contract = 6;
inline bool Account::has_contract() const {
  return this != internal_default_instance() && contract_ != NULL;
}
inline void Account::clear_contract() {
  if (GetArenaNoVirtual() == NULL && contract_ != NULL) {
    delete contract_;
  }
  contract_ = NULL;
}
inline const ::bumoProtocol::Contract& Account::_internal_contract() const {
  return *contract_;
}
inline const ::bumoProtocol::Contract& Account::contract() const {
  const ::bumoProtocol::Contract* p = contract_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Account.contract)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::Contract*>(
      &::bumoProtocol::_Contract_default_instance_);
}
inline ::bumoProtocol::Contract* Account::release_contract() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Account.contract)
  
  ::bumoProtocol::Contract* temp = contract_;
  contract_ = NULL;
  return temp;
}
inline ::bumoProtocol::Contract* Account::mutable_contract() {
  
  if (contract_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::Contract>(GetArenaNoVirtual());
    contract_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Account.contract)
  return contract_;
}
inline void Account::set_allocated_contract(::bumoProtocol::Contract* contract) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete contract_;
  }
  if (contract) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contract = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    
  } else {
    
  }
  contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Account.contract)
}

// int64 balance = 7;
inline void Account::clear_balance() {
  balance_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Account::balance() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Account.balance)
  return balance_;
}
inline void Account::set_balance(::google::protobuf::int64 value) {
  
  balance_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Account.balance)
}

// -------------------------------------------------------------------

// AssetKey

// string issuer = 1;
inline void AssetKey::clear_issuer() {
  issuer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssetKey::issuer() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetKey.issuer)
  return issuer_.GetNoArena();
}
inline void AssetKey::set_issuer(const ::std::string& value) {
  
  issuer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.AssetKey.issuer)
}
#if LANG_CXX11
inline void AssetKey::set_issuer(::std::string&& value) {
  
  issuer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.AssetKey.issuer)
}
#endif
inline void AssetKey::set_issuer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  issuer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.AssetKey.issuer)
}
inline void AssetKey::set_issuer(const char* value, size_t size) {
  
  issuer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.AssetKey.issuer)
}
inline ::std::string* AssetKey::mutable_issuer() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.AssetKey.issuer)
  return issuer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetKey::release_issuer() {
  // @@protoc_insertion_point(field_release:bumoProtocol.AssetKey.issuer)
  
  return issuer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetKey::set_allocated_issuer(::std::string* issuer) {
  if (issuer != NULL) {
    
  } else {
    
  }
  issuer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), issuer);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.AssetKey.issuer)
}

// string code = 2;
inline void AssetKey::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssetKey::code() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetKey.code)
  return code_.GetNoArena();
}
inline void AssetKey::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.AssetKey.code)
}
#if LANG_CXX11
inline void AssetKey::set_code(::std::string&& value) {
  
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.AssetKey.code)
}
#endif
inline void AssetKey::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.AssetKey.code)
}
inline void AssetKey::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.AssetKey.code)
}
inline ::std::string* AssetKey::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.AssetKey.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetKey::release_code() {
  // @@protoc_insertion_point(field_release:bumoProtocol.AssetKey.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetKey::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.AssetKey.code)
}

// int32 type = 3;
inline void AssetKey::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 AssetKey::type() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetKey.type)
  return type_;
}
inline void AssetKey::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.AssetKey.type)
}

// -------------------------------------------------------------------

// Asset

// .bumoProtocol.AssetKey key = 1;
inline bool Asset::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline void Asset::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) {
    delete key_;
  }
  key_ = NULL;
}
inline const ::bumoProtocol::AssetKey& Asset::_internal_key() const {
  return *key_;
}
inline const ::bumoProtocol::AssetKey& Asset::key() const {
  const ::bumoProtocol::AssetKey* p = key_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Asset.key)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::AssetKey*>(
      &::bumoProtocol::_AssetKey_default_instance_);
}
inline ::bumoProtocol::AssetKey* Asset::release_key() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Asset.key)
  
  ::bumoProtocol::AssetKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::bumoProtocol::AssetKey* Asset::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::AssetKey>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Asset.key)
  return key_;
}
inline void Asset::set_allocated_key(::bumoProtocol::AssetKey* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Asset.key)
}

// int64 amount = 2;
inline void Asset::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Asset::amount() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Asset.amount)
  return amount_;
}
inline void Asset::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Asset.amount)
}

// -------------------------------------------------------------------

// AssetProperty

// int32 decimal = 1;
inline void AssetProperty::clear_decimal() {
  decimal_ = 0;
}
inline ::google::protobuf::int32 AssetProperty::decimal() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetProperty.decimal)
  return decimal_;
}
inline void AssetProperty::set_decimal(::google::protobuf::int32 value) {
  
  decimal_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.AssetProperty.decimal)
}

// string description = 2;
inline void AssetProperty::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssetProperty::description() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetProperty.description)
  return description_.GetNoArena();
}
inline void AssetProperty::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.AssetProperty.description)
}
#if LANG_CXX11
inline void AssetProperty::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.AssetProperty.description)
}
#endif
inline void AssetProperty::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.AssetProperty.description)
}
inline void AssetProperty::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.AssetProperty.description)
}
inline ::std::string* AssetProperty::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.AssetProperty.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetProperty::release_description() {
  // @@protoc_insertion_point(field_release:bumoProtocol.AssetProperty.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetProperty::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.AssetProperty.description)
}

// int64 max_supply = 3;
inline void AssetProperty::clear_max_supply() {
  max_supply_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AssetProperty::max_supply() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetProperty.max_supply)
  return max_supply_;
}
inline void AssetProperty::set_max_supply(::google::protobuf::int64 value) {
  
  max_supply_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.AssetProperty.max_supply)
}

// int64 issued_amount = 4;
inline void AssetProperty::clear_issued_amount() {
  issued_amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AssetProperty::issued_amount() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetProperty.issued_amount)
  return issued_amount_;
}
inline void AssetProperty::set_issued_amount(::google::protobuf::int64 value) {
  
  issued_amount_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.AssetProperty.issued_amount)
}

// int32 fee_percent = 5;
inline void AssetProperty::clear_fee_percent() {
  fee_percent_ = 0;
}
inline ::google::protobuf::int32 AssetProperty::fee_percent() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetProperty.fee_percent)
  return fee_percent_;
}
inline void AssetProperty::set_fee_percent(::google::protobuf::int32 value) {
  
  fee_percent_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.AssetProperty.fee_percent)
}

// -------------------------------------------------------------------

// AssetStore

// .bumoProtocol.AssetKey key = 1;
inline bool AssetStore::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline void AssetStore::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) {
    delete key_;
  }
  key_ = NULL;
}
inline const ::bumoProtocol::AssetKey& AssetStore::_internal_key() const {
  return *key_;
}
inline const ::bumoProtocol::AssetKey& AssetStore::key() const {
  const ::bumoProtocol::AssetKey* p = key_;
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetStore.key)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::AssetKey*>(
      &::bumoProtocol::_AssetKey_default_instance_);
}
inline ::bumoProtocol::AssetKey* AssetStore::release_key() {
  // @@protoc_insertion_point(field_release:bumoProtocol.AssetStore.key)
  
  ::bumoProtocol::AssetKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::bumoProtocol::AssetKey* AssetStore::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::AssetKey>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.AssetStore.key)
  return key_;
}
inline void AssetStore::set_allocated_key(::bumoProtocol::AssetKey* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.AssetStore.key)
}

// int64 amount = 2;
inline void AssetStore::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AssetStore::amount() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetStore.amount)
  return amount_;
}
inline void AssetStore::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.AssetStore.amount)
}

// .bumoProtocol.AssetProperty property = 3;
inline bool AssetStore::has_property() const {
  return this != internal_default_instance() && property_ != NULL;
}
inline void AssetStore::clear_property() {
  if (GetArenaNoVirtual() == NULL && property_ != NULL) {
    delete property_;
  }
  property_ = NULL;
}
inline const ::bumoProtocol::AssetProperty& AssetStore::_internal_property() const {
  return *property_;
}
inline const ::bumoProtocol::AssetProperty& AssetStore::property() const {
  const ::bumoProtocol::AssetProperty* p = property_;
  // @@protoc_insertion_point(field_get:bumoProtocol.AssetStore.property)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::AssetProperty*>(
      &::bumoProtocol::_AssetProperty_default_instance_);
}
inline ::bumoProtocol::AssetProperty* AssetStore::release_property() {
  // @@protoc_insertion_point(field_release:bumoProtocol.AssetStore.property)
  
  ::bumoProtocol::AssetProperty* temp = property_;
  property_ = NULL;
  return temp;
}
inline ::bumoProtocol::AssetProperty* AssetStore::mutable_property() {
  
  if (property_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::AssetProperty>(GetArenaNoVirtual());
    property_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.AssetStore.property)
  return property_;
}
inline void AssetStore::set_allocated_property(::bumoProtocol::AssetProperty* property) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete property_;
  }
  if (property) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      property = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, property, submessage_arena);
    }
    
  } else {
    
  }
  property_ = property;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.AssetStore.property)
}

// -------------------------------------------------------------------

// LedgerHeader

// int64 seq = 1;
inline void LedgerHeader::clear_seq() {
  seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerHeader::seq() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.seq)
  return seq_;
}
inline void LedgerHeader::set_seq(::google::protobuf::int64 value) {
  
  seq_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.seq)
}

// bytes hash = 2;
inline void LedgerHeader::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.hash)
  return hash_.GetNoArena();
}
inline void LedgerHeader::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.hash)
}
#if LANG_CXX11
inline void LedgerHeader::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.LedgerHeader.hash)
}
#endif
inline void LedgerHeader::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.LedgerHeader.hash)
}
inline void LedgerHeader::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.LedgerHeader.hash)
}
inline ::std::string* LedgerHeader::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.LedgerHeader.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.LedgerHeader.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.LedgerHeader.hash)
}

// bytes previous_hash = 3;
inline void LedgerHeader::clear_previous_hash() {
  previous_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::previous_hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.previous_hash)
  return previous_hash_.GetNoArena();
}
inline void LedgerHeader::set_previous_hash(const ::std::string& value) {
  
  previous_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.previous_hash)
}
#if LANG_CXX11
inline void LedgerHeader::set_previous_hash(::std::string&& value) {
  
  previous_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.LedgerHeader.previous_hash)
}
#endif
inline void LedgerHeader::set_previous_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  previous_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.LedgerHeader.previous_hash)
}
inline void LedgerHeader::set_previous_hash(const void* value, size_t size) {
  
  previous_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.LedgerHeader.previous_hash)
}
inline ::std::string* LedgerHeader::mutable_previous_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.LedgerHeader.previous_hash)
  return previous_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_previous_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.LedgerHeader.previous_hash)
  
  return previous_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_previous_hash(::std::string* previous_hash) {
  if (previous_hash != NULL) {
    
  } else {
    
  }
  previous_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previous_hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.LedgerHeader.previous_hash)
}

// bytes account_tree_hash = 4;
inline void LedgerHeader::clear_account_tree_hash() {
  account_tree_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::account_tree_hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.account_tree_hash)
  return account_tree_hash_.GetNoArena();
}
inline void LedgerHeader::set_account_tree_hash(const ::std::string& value) {
  
  account_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.account_tree_hash)
}
#if LANG_CXX11
inline void LedgerHeader::set_account_tree_hash(::std::string&& value) {
  
  account_tree_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.LedgerHeader.account_tree_hash)
}
#endif
inline void LedgerHeader::set_account_tree_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.LedgerHeader.account_tree_hash)
}
inline void LedgerHeader::set_account_tree_hash(const void* value, size_t size) {
  
  account_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.LedgerHeader.account_tree_hash)
}
inline ::std::string* LedgerHeader::mutable_account_tree_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.LedgerHeader.account_tree_hash)
  return account_tree_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_account_tree_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.LedgerHeader.account_tree_hash)
  
  return account_tree_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_account_tree_hash(::std::string* account_tree_hash) {
  if (account_tree_hash != NULL) {
    
  } else {
    
  }
  account_tree_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_tree_hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.LedgerHeader.account_tree_hash)
}

// int64 close_time = 5;
inline void LedgerHeader::clear_close_time() {
  close_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerHeader::close_time() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.close_time)
  return close_time_;
}
inline void LedgerHeader::set_close_time(::google::protobuf::int64 value) {
  
  close_time_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.close_time)
}

// bytes consensus_value_hash = 6;
inline void LedgerHeader::clear_consensus_value_hash() {
  consensus_value_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::consensus_value_hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.consensus_value_hash)
  return consensus_value_hash_.GetNoArena();
}
inline void LedgerHeader::set_consensus_value_hash(const ::std::string& value) {
  
  consensus_value_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.consensus_value_hash)
}
#if LANG_CXX11
inline void LedgerHeader::set_consensus_value_hash(::std::string&& value) {
  
  consensus_value_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.LedgerHeader.consensus_value_hash)
}
#endif
inline void LedgerHeader::set_consensus_value_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  consensus_value_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.LedgerHeader.consensus_value_hash)
}
inline void LedgerHeader::set_consensus_value_hash(const void* value, size_t size) {
  
  consensus_value_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.LedgerHeader.consensus_value_hash)
}
inline ::std::string* LedgerHeader::mutable_consensus_value_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.LedgerHeader.consensus_value_hash)
  return consensus_value_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_consensus_value_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.LedgerHeader.consensus_value_hash)
  
  return consensus_value_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_consensus_value_hash(::std::string* consensus_value_hash) {
  if (consensus_value_hash != NULL) {
    
  } else {
    
  }
  consensus_value_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), consensus_value_hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.LedgerHeader.consensus_value_hash)
}

// int64 version = 7;
inline void LedgerHeader::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerHeader::version() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.version)
  return version_;
}
inline void LedgerHeader::set_version(::google::protobuf::int64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.version)
}

// int64 tx_count = 8;
inline void LedgerHeader::clear_tx_count() {
  tx_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LedgerHeader::tx_count() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.tx_count)
  return tx_count_;
}
inline void LedgerHeader::set_tx_count(::google::protobuf::int64 value) {
  
  tx_count_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.tx_count)
}

// bytes validators_hash = 9;
inline void LedgerHeader::clear_validators_hash() {
  validators_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::validators_hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.validators_hash)
  return validators_hash_.GetNoArena();
}
inline void LedgerHeader::set_validators_hash(const ::std::string& value) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.validators_hash)
}
#if LANG_CXX11
inline void LedgerHeader::set_validators_hash(::std::string&& value) {
  
  validators_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.LedgerHeader.validators_hash)
}
#endif
inline void LedgerHeader::set_validators_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.LedgerHeader.validators_hash)
}
inline void LedgerHeader::set_validators_hash(const void* value, size_t size) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.LedgerHeader.validators_hash)
}
inline ::std::string* LedgerHeader::mutable_validators_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.LedgerHeader.validators_hash)
  return validators_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_validators_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.LedgerHeader.validators_hash)
  
  return validators_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_validators_hash(::std::string* validators_hash) {
  if (validators_hash != NULL) {
    
  } else {
    
  }
  validators_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), validators_hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.LedgerHeader.validators_hash)
}

// bytes fees_hash = 10;
inline void LedgerHeader::clear_fees_hash() {
  fees_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::fees_hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.fees_hash)
  return fees_hash_.GetNoArena();
}
inline void LedgerHeader::set_fees_hash(const ::std::string& value) {
  
  fees_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.fees_hash)
}
#if LANG_CXX11
inline void LedgerHeader::set_fees_hash(::std::string&& value) {
  
  fees_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.LedgerHeader.fees_hash)
}
#endif
inline void LedgerHeader::set_fees_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fees_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.LedgerHeader.fees_hash)
}
inline void LedgerHeader::set_fees_hash(const void* value, size_t size) {
  
  fees_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.LedgerHeader.fees_hash)
}
inline ::std::string* LedgerHeader::mutable_fees_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.LedgerHeader.fees_hash)
  return fees_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_fees_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.LedgerHeader.fees_hash)
  
  return fees_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_fees_hash(::std::string* fees_hash) {
  if (fees_hash != NULL) {
    
  } else {
    
  }
  fees_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fees_hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.LedgerHeader.fees_hash)
}

// string reserve = 11;
inline void LedgerHeader::clear_reserve() {
  reserve_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LedgerHeader::reserve() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.LedgerHeader.reserve)
  return reserve_.GetNoArena();
}
inline void LedgerHeader::set_reserve(const ::std::string& value) {
  
  reserve_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.LedgerHeader.reserve)
}
#if LANG_CXX11
inline void LedgerHeader::set_reserve(::std::string&& value) {
  
  reserve_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.LedgerHeader.reserve)
}
#endif
inline void LedgerHeader::set_reserve(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  reserve_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.LedgerHeader.reserve)
}
inline void LedgerHeader::set_reserve(const char* value, size_t size) {
  
  reserve_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.LedgerHeader.reserve)
}
inline ::std::string* LedgerHeader::mutable_reserve() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.LedgerHeader.reserve)
  return reserve_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_reserve() {
  // @@protoc_insertion_point(field_release:bumoProtocol.LedgerHeader.reserve)
  
  return reserve_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_reserve(::std::string* reserve) {
  if (reserve != NULL) {
    
  } else {
    
  }
  reserve_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reserve);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.LedgerHeader.reserve)
}

// -------------------------------------------------------------------

// Ledger

// .bumoProtocol.LedgerHeader header = 1;
inline bool Ledger::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Ledger::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::bumoProtocol::LedgerHeader& Ledger::_internal_header() const {
  return *header_;
}
inline const ::bumoProtocol::LedgerHeader& Ledger::header() const {
  const ::bumoProtocol::LedgerHeader* p = header_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Ledger.header)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::LedgerHeader*>(
      &::bumoProtocol::_LedgerHeader_default_instance_);
}
inline ::bumoProtocol::LedgerHeader* Ledger::release_header() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Ledger.header)
  
  ::bumoProtocol::LedgerHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::bumoProtocol::LedgerHeader* Ledger::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::LedgerHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Ledger.header)
  return header_;
}
inline void Ledger::set_allocated_header(::bumoProtocol::LedgerHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Ledger.header)
}

// repeated .bumoProtocol.TransactionEnv transaction_envs = 2;
inline int Ledger::transaction_envs_size() const {
  return transaction_envs_.size();
}
inline void Ledger::clear_transaction_envs() {
  transaction_envs_.Clear();
}
inline ::bumoProtocol::TransactionEnv* Ledger::mutable_transaction_envs(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Ledger.transaction_envs)
  return transaction_envs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::TransactionEnv >*
Ledger::mutable_transaction_envs() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.Ledger.transaction_envs)
  return &transaction_envs_;
}
inline const ::bumoProtocol::TransactionEnv& Ledger::transaction_envs(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Ledger.transaction_envs)
  return transaction_envs_.Get(index);
}
inline ::bumoProtocol::TransactionEnv* Ledger::add_transaction_envs() {
  // @@protoc_insertion_point(field_add:bumoProtocol.Ledger.transaction_envs)
  return transaction_envs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::TransactionEnv >&
Ledger::transaction_envs() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.Ledger.transaction_envs)
  return transaction_envs_;
}

// -------------------------------------------------------------------

// OperationPayAsset

// string dest_address = 1;
inline void OperationPayAsset::clear_dest_address() {
  dest_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationPayAsset::dest_address() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationPayAsset.dest_address)
  return dest_address_.GetNoArena();
}
inline void OperationPayAsset::set_dest_address(const ::std::string& value) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationPayAsset.dest_address)
}
#if LANG_CXX11
inline void OperationPayAsset::set_dest_address(::std::string&& value) {
  
  dest_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationPayAsset.dest_address)
}
#endif
inline void OperationPayAsset::set_dest_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationPayAsset.dest_address)
}
inline void OperationPayAsset::set_dest_address(const char* value, size_t size) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationPayAsset.dest_address)
}
inline ::std::string* OperationPayAsset::mutable_dest_address() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationPayAsset.dest_address)
  return dest_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationPayAsset::release_dest_address() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationPayAsset.dest_address)
  
  return dest_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayAsset::set_allocated_dest_address(::std::string* dest_address) {
  if (dest_address != NULL) {
    
  } else {
    
  }
  dest_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_address);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationPayAsset.dest_address)
}

// .bumoProtocol.Asset asset = 2;
inline bool OperationPayAsset::has_asset() const {
  return this != internal_default_instance() && asset_ != NULL;
}
inline void OperationPayAsset::clear_asset() {
  if (GetArenaNoVirtual() == NULL && asset_ != NULL) {
    delete asset_;
  }
  asset_ = NULL;
}
inline const ::bumoProtocol::Asset& OperationPayAsset::_internal_asset() const {
  return *asset_;
}
inline const ::bumoProtocol::Asset& OperationPayAsset::asset() const {
  const ::bumoProtocol::Asset* p = asset_;
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationPayAsset.asset)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::Asset*>(
      &::bumoProtocol::_Asset_default_instance_);
}
inline ::bumoProtocol::Asset* OperationPayAsset::release_asset() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationPayAsset.asset)
  
  ::bumoProtocol::Asset* temp = asset_;
  asset_ = NULL;
  return temp;
}
inline ::bumoProtocol::Asset* OperationPayAsset::mutable_asset() {
  
  if (asset_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::Asset>(GetArenaNoVirtual());
    asset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationPayAsset.asset)
  return asset_;
}
inline void OperationPayAsset::set_allocated_asset(::bumoProtocol::Asset* asset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete asset_;
  }
  if (asset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      asset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, asset, submessage_arena);
    }
    
  } else {
    
  }
  asset_ = asset;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationPayAsset.asset)
}

// string input = 3;
inline void OperationPayAsset::clear_input() {
  input_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationPayAsset::input() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationPayAsset.input)
  return input_.GetNoArena();
}
inline void OperationPayAsset::set_input(const ::std::string& value) {
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationPayAsset.input)
}
#if LANG_CXX11
inline void OperationPayAsset::set_input(::std::string&& value) {
  
  input_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationPayAsset.input)
}
#endif
inline void OperationPayAsset::set_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationPayAsset.input)
}
inline void OperationPayAsset::set_input(const char* value, size_t size) {
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationPayAsset.input)
}
inline ::std::string* OperationPayAsset::mutable_input() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationPayAsset.input)
  return input_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationPayAsset::release_input() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationPayAsset.input)
  
  return input_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayAsset::set_allocated_input(::std::string* input) {
  if (input != NULL) {
    
  } else {
    
  }
  input_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationPayAsset.input)
}

// -------------------------------------------------------------------

// OperationTypeThreshold

// .bumoProtocol.Operation.Type type = 1;
inline void OperationTypeThreshold::clear_type() {
  type_ = 0;
}
inline ::bumoProtocol::Operation_Type OperationTypeThreshold::type() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationTypeThreshold.type)
  return static_cast< ::bumoProtocol::Operation_Type >(type_);
}
inline void OperationTypeThreshold::set_type(::bumoProtocol::Operation_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationTypeThreshold.type)
}

// int64 threshold = 2;
inline void OperationTypeThreshold::clear_threshold() {
  threshold_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationTypeThreshold::threshold() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationTypeThreshold.threshold)
  return threshold_;
}
inline void OperationTypeThreshold::set_threshold(::google::protobuf::int64 value) {
  
  threshold_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationTypeThreshold.threshold)
}

// -------------------------------------------------------------------

// AccountPrivilege

// int64 master_weight = 1;
inline void AccountPrivilege::clear_master_weight() {
  master_weight_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountPrivilege::master_weight() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AccountPrivilege.master_weight)
  return master_weight_;
}
inline void AccountPrivilege::set_master_weight(::google::protobuf::int64 value) {
  
  master_weight_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.AccountPrivilege.master_weight)
}

// repeated .bumoProtocol.Signer signers = 2;
inline int AccountPrivilege::signers_size() const {
  return signers_.size();
}
inline void AccountPrivilege::clear_signers() {
  signers_.Clear();
}
inline ::bumoProtocol::Signer* AccountPrivilege::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.AccountPrivilege.signers)
  return signers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >*
AccountPrivilege::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.AccountPrivilege.signers)
  return &signers_;
}
inline const ::bumoProtocol::Signer& AccountPrivilege::signers(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AccountPrivilege.signers)
  return signers_.Get(index);
}
inline ::bumoProtocol::Signer* AccountPrivilege::add_signers() {
  // @@protoc_insertion_point(field_add:bumoProtocol.AccountPrivilege.signers)
  return signers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >&
AccountPrivilege::signers() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.AccountPrivilege.signers)
  return signers_;
}

// .bumoProtocol.AccountThreshold thresholds = 3;
inline bool AccountPrivilege::has_thresholds() const {
  return this != internal_default_instance() && thresholds_ != NULL;
}
inline void AccountPrivilege::clear_thresholds() {
  if (GetArenaNoVirtual() == NULL && thresholds_ != NULL) {
    delete thresholds_;
  }
  thresholds_ = NULL;
}
inline const ::bumoProtocol::AccountThreshold& AccountPrivilege::_internal_thresholds() const {
  return *thresholds_;
}
inline const ::bumoProtocol::AccountThreshold& AccountPrivilege::thresholds() const {
  const ::bumoProtocol::AccountThreshold* p = thresholds_;
  // @@protoc_insertion_point(field_get:bumoProtocol.AccountPrivilege.thresholds)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::AccountThreshold*>(
      &::bumoProtocol::_AccountThreshold_default_instance_);
}
inline ::bumoProtocol::AccountThreshold* AccountPrivilege::release_thresholds() {
  // @@protoc_insertion_point(field_release:bumoProtocol.AccountPrivilege.thresholds)
  
  ::bumoProtocol::AccountThreshold* temp = thresholds_;
  thresholds_ = NULL;
  return temp;
}
inline ::bumoProtocol::AccountThreshold* AccountPrivilege::mutable_thresholds() {
  
  if (thresholds_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::AccountThreshold>(GetArenaNoVirtual());
    thresholds_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.AccountPrivilege.thresholds)
  return thresholds_;
}
inline void AccountPrivilege::set_allocated_thresholds(::bumoProtocol::AccountThreshold* thresholds) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete thresholds_;
  }
  if (thresholds) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      thresholds = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, thresholds, submessage_arena);
    }
    
  } else {
    
  }
  thresholds_ = thresholds;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.AccountPrivilege.thresholds)
}

// -------------------------------------------------------------------

// AccountThreshold

// int64 tx_threshold = 1;
inline void AccountThreshold::clear_tx_threshold() {
  tx_threshold_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountThreshold::tx_threshold() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AccountThreshold.tx_threshold)
  return tx_threshold_;
}
inline void AccountThreshold::set_tx_threshold(::google::protobuf::int64 value) {
  
  tx_threshold_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.AccountThreshold.tx_threshold)
}

// repeated .bumoProtocol.OperationTypeThreshold type_thresholds = 2;
inline int AccountThreshold::type_thresholds_size() const {
  return type_thresholds_.size();
}
inline void AccountThreshold::clear_type_thresholds() {
  type_thresholds_.Clear();
}
inline ::bumoProtocol::OperationTypeThreshold* AccountThreshold::mutable_type_thresholds(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.AccountThreshold.type_thresholds)
  return type_thresholds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >*
AccountThreshold::mutable_type_thresholds() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.AccountThreshold.type_thresholds)
  return &type_thresholds_;
}
inline const ::bumoProtocol::OperationTypeThreshold& AccountThreshold::type_thresholds(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.AccountThreshold.type_thresholds)
  return type_thresholds_.Get(index);
}
inline ::bumoProtocol::OperationTypeThreshold* AccountThreshold::add_type_thresholds() {
  // @@protoc_insertion_point(field_add:bumoProtocol.AccountThreshold.type_thresholds)
  return type_thresholds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >&
AccountThreshold::type_thresholds() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.AccountThreshold.type_thresholds)
  return type_thresholds_;
}

// -------------------------------------------------------------------

// OperationIssueAsset

// string code = 1;
inline void OperationIssueAsset::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationIssueAsset::code() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationIssueAsset.code)
  return code_.GetNoArena();
}
inline void OperationIssueAsset::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationIssueAsset.code)
}
#if LANG_CXX11
inline void OperationIssueAsset::set_code(::std::string&& value) {
  
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationIssueAsset.code)
}
#endif
inline void OperationIssueAsset::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationIssueAsset.code)
}
inline void OperationIssueAsset::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationIssueAsset.code)
}
inline ::std::string* OperationIssueAsset::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationIssueAsset.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationIssueAsset::release_code() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationIssueAsset.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationIssueAsset::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationIssueAsset.code)
}

// int64 amount = 2;
inline void OperationIssueAsset::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationIssueAsset::amount() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationIssueAsset.amount)
  return amount_;
}
inline void OperationIssueAsset::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationIssueAsset.amount)
}

// -------------------------------------------------------------------

// OperationPayCoin

// string dest_address = 1;
inline void OperationPayCoin::clear_dest_address() {
  dest_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationPayCoin::dest_address() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationPayCoin.dest_address)
  return dest_address_.GetNoArena();
}
inline void OperationPayCoin::set_dest_address(const ::std::string& value) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationPayCoin.dest_address)
}
#if LANG_CXX11
inline void OperationPayCoin::set_dest_address(::std::string&& value) {
  
  dest_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationPayCoin.dest_address)
}
#endif
inline void OperationPayCoin::set_dest_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationPayCoin.dest_address)
}
inline void OperationPayCoin::set_dest_address(const char* value, size_t size) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationPayCoin.dest_address)
}
inline ::std::string* OperationPayCoin::mutable_dest_address() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationPayCoin.dest_address)
  return dest_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationPayCoin::release_dest_address() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationPayCoin.dest_address)
  
  return dest_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayCoin::set_allocated_dest_address(::std::string* dest_address) {
  if (dest_address != NULL) {
    
  } else {
    
  }
  dest_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_address);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationPayCoin.dest_address)
}

// int64 amount = 2;
inline void OperationPayCoin::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationPayCoin::amount() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationPayCoin.amount)
  return amount_;
}
inline void OperationPayCoin::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationPayCoin.amount)
}

// string input = 3;
inline void OperationPayCoin::clear_input() {
  input_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationPayCoin::input() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationPayCoin.input)
  return input_.GetNoArena();
}
inline void OperationPayCoin::set_input(const ::std::string& value) {
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationPayCoin.input)
}
#if LANG_CXX11
inline void OperationPayCoin::set_input(::std::string&& value) {
  
  input_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationPayCoin.input)
}
#endif
inline void OperationPayCoin::set_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationPayCoin.input)
}
inline void OperationPayCoin::set_input(const char* value, size_t size) {
  
  input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationPayCoin.input)
}
inline ::std::string* OperationPayCoin::mutable_input() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationPayCoin.input)
  return input_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationPayCoin::release_input() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationPayCoin.input)
  
  return input_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayCoin::set_allocated_input(::std::string* input) {
  if (input != NULL) {
    
  } else {
    
  }
  input_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationPayCoin.input)
}

// -------------------------------------------------------------------

// OperationSetSignerWeight

// int64 master_weight = 1;
inline void OperationSetSignerWeight::clear_master_weight() {
  master_weight_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationSetSignerWeight::master_weight() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetSignerWeight.master_weight)
  return master_weight_;
}
inline void OperationSetSignerWeight::set_master_weight(::google::protobuf::int64 value) {
  
  master_weight_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationSetSignerWeight.master_weight)
}

// repeated .bumoProtocol.Signer signers = 2;
inline int OperationSetSignerWeight::signers_size() const {
  return signers_.size();
}
inline void OperationSetSignerWeight::clear_signers() {
  signers_.Clear();
}
inline ::bumoProtocol::Signer* OperationSetSignerWeight::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationSetSignerWeight.signers)
  return signers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >*
OperationSetSignerWeight::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.OperationSetSignerWeight.signers)
  return &signers_;
}
inline const ::bumoProtocol::Signer& OperationSetSignerWeight::signers(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetSignerWeight.signers)
  return signers_.Get(index);
}
inline ::bumoProtocol::Signer* OperationSetSignerWeight::add_signers() {
  // @@protoc_insertion_point(field_add:bumoProtocol.OperationSetSignerWeight.signers)
  return signers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >&
OperationSetSignerWeight::signers() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.OperationSetSignerWeight.signers)
  return signers_;
}

// -------------------------------------------------------------------

// OperationLog

// string topic = 1;
inline void OperationLog::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationLog::topic() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationLog.topic)
  return topic_.GetNoArena();
}
inline void OperationLog::set_topic(const ::std::string& value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationLog.topic)
}
#if LANG_CXX11
inline void OperationLog::set_topic(::std::string&& value) {
  
  topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationLog.topic)
}
#endif
inline void OperationLog::set_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationLog.topic)
}
inline void OperationLog::set_topic(const char* value, size_t size) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationLog.topic)
}
inline ::std::string* OperationLog::mutable_topic() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationLog.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationLog::release_topic() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationLog.topic)
  
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationLog::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    
  } else {
    
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationLog.topic)
}

// repeated string datas = 2;
inline int OperationLog::datas_size() const {
  return datas_.size();
}
inline void OperationLog::clear_datas() {
  datas_.Clear();
}
inline const ::std::string& OperationLog::datas(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationLog.datas)
  return datas_.Get(index);
}
inline ::std::string* OperationLog::mutable_datas(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationLog.datas)
  return datas_.Mutable(index);
}
inline void OperationLog::set_datas(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationLog.datas)
  datas_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OperationLog::set_datas(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationLog.datas)
  datas_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OperationLog::set_datas(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  datas_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationLog.datas)
}
inline void OperationLog::set_datas(int index, const char* value, size_t size) {
  datas_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationLog.datas)
}
inline ::std::string* OperationLog::add_datas() {
  // @@protoc_insertion_point(field_add_mutable:bumoProtocol.OperationLog.datas)
  return datas_.Add();
}
inline void OperationLog::add_datas(const ::std::string& value) {
  datas_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bumoProtocol.OperationLog.datas)
}
#if LANG_CXX11
inline void OperationLog::add_datas(::std::string&& value) {
  datas_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bumoProtocol.OperationLog.datas)
}
#endif
inline void OperationLog::add_datas(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  datas_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bumoProtocol.OperationLog.datas)
}
inline void OperationLog::add_datas(const char* value, size_t size) {
  datas_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bumoProtocol.OperationLog.datas)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperationLog::datas() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.OperationLog.datas)
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperationLog::mutable_datas() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.OperationLog.datas)
  return &datas_;
}

// -------------------------------------------------------------------

// OperationSetPrivilege

// string master_weight = 1;
inline void OperationSetPrivilege::clear_master_weight() {
  master_weight_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationSetPrivilege::master_weight() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetPrivilege.master_weight)
  return master_weight_.GetNoArena();
}
inline void OperationSetPrivilege::set_master_weight(const ::std::string& value) {
  
  master_weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationSetPrivilege.master_weight)
}
#if LANG_CXX11
inline void OperationSetPrivilege::set_master_weight(::std::string&& value) {
  
  master_weight_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationSetPrivilege.master_weight)
}
#endif
inline void OperationSetPrivilege::set_master_weight(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  master_weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationSetPrivilege.master_weight)
}
inline void OperationSetPrivilege::set_master_weight(const char* value, size_t size) {
  
  master_weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationSetPrivilege.master_weight)
}
inline ::std::string* OperationSetPrivilege::mutable_master_weight() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationSetPrivilege.master_weight)
  return master_weight_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationSetPrivilege::release_master_weight() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationSetPrivilege.master_weight)
  
  return master_weight_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetPrivilege::set_allocated_master_weight(::std::string* master_weight) {
  if (master_weight != NULL) {
    
  } else {
    
  }
  master_weight_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), master_weight);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationSetPrivilege.master_weight)
}

// repeated .bumoProtocol.Signer signers = 2;
inline int OperationSetPrivilege::signers_size() const {
  return signers_.size();
}
inline void OperationSetPrivilege::clear_signers() {
  signers_.Clear();
}
inline ::bumoProtocol::Signer* OperationSetPrivilege::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationSetPrivilege.signers)
  return signers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >*
OperationSetPrivilege::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.OperationSetPrivilege.signers)
  return &signers_;
}
inline const ::bumoProtocol::Signer& OperationSetPrivilege::signers(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetPrivilege.signers)
  return signers_.Get(index);
}
inline ::bumoProtocol::Signer* OperationSetPrivilege::add_signers() {
  // @@protoc_insertion_point(field_add:bumoProtocol.OperationSetPrivilege.signers)
  return signers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signer >&
OperationSetPrivilege::signers() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.OperationSetPrivilege.signers)
  return signers_;
}

// string tx_threshold = 3;
inline void OperationSetPrivilege::clear_tx_threshold() {
  tx_threshold_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationSetPrivilege::tx_threshold() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetPrivilege.tx_threshold)
  return tx_threshold_.GetNoArena();
}
inline void OperationSetPrivilege::set_tx_threshold(const ::std::string& value) {
  
  tx_threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationSetPrivilege.tx_threshold)
}
#if LANG_CXX11
inline void OperationSetPrivilege::set_tx_threshold(::std::string&& value) {
  
  tx_threshold_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationSetPrivilege.tx_threshold)
}
#endif
inline void OperationSetPrivilege::set_tx_threshold(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tx_threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationSetPrivilege.tx_threshold)
}
inline void OperationSetPrivilege::set_tx_threshold(const char* value, size_t size) {
  
  tx_threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationSetPrivilege.tx_threshold)
}
inline ::std::string* OperationSetPrivilege::mutable_tx_threshold() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationSetPrivilege.tx_threshold)
  return tx_threshold_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationSetPrivilege::release_tx_threshold() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationSetPrivilege.tx_threshold)
  
  return tx_threshold_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetPrivilege::set_allocated_tx_threshold(::std::string* tx_threshold) {
  if (tx_threshold != NULL) {
    
  } else {
    
  }
  tx_threshold_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_threshold);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationSetPrivilege.tx_threshold)
}

// repeated .bumoProtocol.OperationTypeThreshold type_thresholds = 4;
inline int OperationSetPrivilege::type_thresholds_size() const {
  return type_thresholds_.size();
}
inline void OperationSetPrivilege::clear_type_thresholds() {
  type_thresholds_.Clear();
}
inline ::bumoProtocol::OperationTypeThreshold* OperationSetPrivilege::mutable_type_thresholds(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationSetPrivilege.type_thresholds)
  return type_thresholds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >*
OperationSetPrivilege::mutable_type_thresholds() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.OperationSetPrivilege.type_thresholds)
  return &type_thresholds_;
}
inline const ::bumoProtocol::OperationTypeThreshold& OperationSetPrivilege::type_thresholds(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetPrivilege.type_thresholds)
  return type_thresholds_.Get(index);
}
inline ::bumoProtocol::OperationTypeThreshold* OperationSetPrivilege::add_type_thresholds() {
  // @@protoc_insertion_point(field_add:bumoProtocol.OperationSetPrivilege.type_thresholds)
  return type_thresholds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >&
OperationSetPrivilege::type_thresholds() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.OperationSetPrivilege.type_thresholds)
  return type_thresholds_;
}

// -------------------------------------------------------------------

// Operation

// .bumoProtocol.Operation.Type type = 1;
inline void Operation::clear_type() {
  type_ = 0;
}
inline ::bumoProtocol::Operation_Type Operation::type() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.type)
  return static_cast< ::bumoProtocol::Operation_Type >(type_);
}
inline void Operation::set_type(::bumoProtocol::Operation_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Operation.type)
}

// string source_address = 2;
inline void Operation::clear_source_address() {
  source_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Operation::source_address() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.source_address)
  return source_address_.GetNoArena();
}
inline void Operation::set_source_address(const ::std::string& value) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.Operation.source_address)
}
#if LANG_CXX11
inline void Operation::set_source_address(::std::string&& value) {
  
  source_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.Operation.source_address)
}
#endif
inline void Operation::set_source_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.Operation.source_address)
}
inline void Operation::set_source_address(const char* value, size_t size) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.Operation.source_address)
}
inline ::std::string* Operation::mutable_source_address() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.source_address)
  return source_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operation::release_source_address() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.source_address)
  
  return source_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_allocated_source_address(::std::string* source_address) {
  if (source_address != NULL) {
    
  } else {
    
  }
  source_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_address);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.source_address)
}

// bytes metadata = 3;
inline void Operation::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Operation::metadata() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.metadata)
  return metadata_.GetNoArena();
}
inline void Operation::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.Operation.metadata)
}
#if LANG_CXX11
inline void Operation::set_metadata(::std::string&& value) {
  
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.Operation.metadata)
}
#endif
inline void Operation::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.Operation.metadata)
}
inline void Operation::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.Operation.metadata)
}
inline ::std::string* Operation::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operation::release_metadata() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.metadata)
}

// .bumoProtocol.OperationCreateAccount create_account = 4;
inline bool Operation::has_create_account() const {
  return this != internal_default_instance() && create_account_ != NULL;
}
inline void Operation::clear_create_account() {
  if (GetArenaNoVirtual() == NULL && create_account_ != NULL) {
    delete create_account_;
  }
  create_account_ = NULL;
}
inline const ::bumoProtocol::OperationCreateAccount& Operation::_internal_create_account() const {
  return *create_account_;
}
inline const ::bumoProtocol::OperationCreateAccount& Operation::create_account() const {
  const ::bumoProtocol::OperationCreateAccount* p = create_account_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.create_account)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::OperationCreateAccount*>(
      &::bumoProtocol::_OperationCreateAccount_default_instance_);
}
inline ::bumoProtocol::OperationCreateAccount* Operation::release_create_account() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.create_account)
  
  ::bumoProtocol::OperationCreateAccount* temp = create_account_;
  create_account_ = NULL;
  return temp;
}
inline ::bumoProtocol::OperationCreateAccount* Operation::mutable_create_account() {
  
  if (create_account_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::OperationCreateAccount>(GetArenaNoVirtual());
    create_account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.create_account)
  return create_account_;
}
inline void Operation::set_allocated_create_account(::bumoProtocol::OperationCreateAccount* create_account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete create_account_;
  }
  if (create_account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      create_account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_account, submessage_arena);
    }
    
  } else {
    
  }
  create_account_ = create_account;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.create_account)
}

// .bumoProtocol.OperationIssueAsset issue_asset = 5;
inline bool Operation::has_issue_asset() const {
  return this != internal_default_instance() && issue_asset_ != NULL;
}
inline void Operation::clear_issue_asset() {
  if (GetArenaNoVirtual() == NULL && issue_asset_ != NULL) {
    delete issue_asset_;
  }
  issue_asset_ = NULL;
}
inline const ::bumoProtocol::OperationIssueAsset& Operation::_internal_issue_asset() const {
  return *issue_asset_;
}
inline const ::bumoProtocol::OperationIssueAsset& Operation::issue_asset() const {
  const ::bumoProtocol::OperationIssueAsset* p = issue_asset_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.issue_asset)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::OperationIssueAsset*>(
      &::bumoProtocol::_OperationIssueAsset_default_instance_);
}
inline ::bumoProtocol::OperationIssueAsset* Operation::release_issue_asset() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.issue_asset)
  
  ::bumoProtocol::OperationIssueAsset* temp = issue_asset_;
  issue_asset_ = NULL;
  return temp;
}
inline ::bumoProtocol::OperationIssueAsset* Operation::mutable_issue_asset() {
  
  if (issue_asset_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::OperationIssueAsset>(GetArenaNoVirtual());
    issue_asset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.issue_asset)
  return issue_asset_;
}
inline void Operation::set_allocated_issue_asset(::bumoProtocol::OperationIssueAsset* issue_asset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete issue_asset_;
  }
  if (issue_asset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      issue_asset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, issue_asset, submessage_arena);
    }
    
  } else {
    
  }
  issue_asset_ = issue_asset;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.issue_asset)
}

// .bumoProtocol.OperationPayAsset pay_asset = 6;
inline bool Operation::has_pay_asset() const {
  return this != internal_default_instance() && pay_asset_ != NULL;
}
inline void Operation::clear_pay_asset() {
  if (GetArenaNoVirtual() == NULL && pay_asset_ != NULL) {
    delete pay_asset_;
  }
  pay_asset_ = NULL;
}
inline const ::bumoProtocol::OperationPayAsset& Operation::_internal_pay_asset() const {
  return *pay_asset_;
}
inline const ::bumoProtocol::OperationPayAsset& Operation::pay_asset() const {
  const ::bumoProtocol::OperationPayAsset* p = pay_asset_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.pay_asset)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::OperationPayAsset*>(
      &::bumoProtocol::_OperationPayAsset_default_instance_);
}
inline ::bumoProtocol::OperationPayAsset* Operation::release_pay_asset() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.pay_asset)
  
  ::bumoProtocol::OperationPayAsset* temp = pay_asset_;
  pay_asset_ = NULL;
  return temp;
}
inline ::bumoProtocol::OperationPayAsset* Operation::mutable_pay_asset() {
  
  if (pay_asset_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::OperationPayAsset>(GetArenaNoVirtual());
    pay_asset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.pay_asset)
  return pay_asset_;
}
inline void Operation::set_allocated_pay_asset(::bumoProtocol::OperationPayAsset* pay_asset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pay_asset_;
  }
  if (pay_asset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pay_asset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pay_asset, submessage_arena);
    }
    
  } else {
    
  }
  pay_asset_ = pay_asset;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.pay_asset)
}

// .bumoProtocol.OperationSetMetadata set_metadata = 7;
inline bool Operation::has_set_metadata() const {
  return this != internal_default_instance() && set_metadata_ != NULL;
}
inline void Operation::clear_set_metadata() {
  if (GetArenaNoVirtual() == NULL && set_metadata_ != NULL) {
    delete set_metadata_;
  }
  set_metadata_ = NULL;
}
inline const ::bumoProtocol::OperationSetMetadata& Operation::_internal_set_metadata() const {
  return *set_metadata_;
}
inline const ::bumoProtocol::OperationSetMetadata& Operation::set_metadata() const {
  const ::bumoProtocol::OperationSetMetadata* p = set_metadata_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.set_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::OperationSetMetadata*>(
      &::bumoProtocol::_OperationSetMetadata_default_instance_);
}
inline ::bumoProtocol::OperationSetMetadata* Operation::release_set_metadata() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.set_metadata)
  
  ::bumoProtocol::OperationSetMetadata* temp = set_metadata_;
  set_metadata_ = NULL;
  return temp;
}
inline ::bumoProtocol::OperationSetMetadata* Operation::mutable_set_metadata() {
  
  if (set_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::OperationSetMetadata>(GetArenaNoVirtual());
    set_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.set_metadata)
  return set_metadata_;
}
inline void Operation::set_allocated_set_metadata(::bumoProtocol::OperationSetMetadata* set_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete set_metadata_;
  }
  if (set_metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      set_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, set_metadata, submessage_arena);
    }
    
  } else {
    
  }
  set_metadata_ = set_metadata;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.set_metadata)
}

// .bumoProtocol.OperationSetSignerWeight set_signer_weight = 8;
inline bool Operation::has_set_signer_weight() const {
  return this != internal_default_instance() && set_signer_weight_ != NULL;
}
inline void Operation::clear_set_signer_weight() {
  if (GetArenaNoVirtual() == NULL && set_signer_weight_ != NULL) {
    delete set_signer_weight_;
  }
  set_signer_weight_ = NULL;
}
inline const ::bumoProtocol::OperationSetSignerWeight& Operation::_internal_set_signer_weight() const {
  return *set_signer_weight_;
}
inline const ::bumoProtocol::OperationSetSignerWeight& Operation::set_signer_weight() const {
  const ::bumoProtocol::OperationSetSignerWeight* p = set_signer_weight_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.set_signer_weight)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::OperationSetSignerWeight*>(
      &::bumoProtocol::_OperationSetSignerWeight_default_instance_);
}
inline ::bumoProtocol::OperationSetSignerWeight* Operation::release_set_signer_weight() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.set_signer_weight)
  
  ::bumoProtocol::OperationSetSignerWeight* temp = set_signer_weight_;
  set_signer_weight_ = NULL;
  return temp;
}
inline ::bumoProtocol::OperationSetSignerWeight* Operation::mutable_set_signer_weight() {
  
  if (set_signer_weight_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::OperationSetSignerWeight>(GetArenaNoVirtual());
    set_signer_weight_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.set_signer_weight)
  return set_signer_weight_;
}
inline void Operation::set_allocated_set_signer_weight(::bumoProtocol::OperationSetSignerWeight* set_signer_weight) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete set_signer_weight_;
  }
  if (set_signer_weight) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      set_signer_weight = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, set_signer_weight, submessage_arena);
    }
    
  } else {
    
  }
  set_signer_weight_ = set_signer_weight;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.set_signer_weight)
}

// .bumoProtocol.OperationSetThreshold set_threshold = 9;
inline bool Operation::has_set_threshold() const {
  return this != internal_default_instance() && set_threshold_ != NULL;
}
inline void Operation::clear_set_threshold() {
  if (GetArenaNoVirtual() == NULL && set_threshold_ != NULL) {
    delete set_threshold_;
  }
  set_threshold_ = NULL;
}
inline const ::bumoProtocol::OperationSetThreshold& Operation::_internal_set_threshold() const {
  return *set_threshold_;
}
inline const ::bumoProtocol::OperationSetThreshold& Operation::set_threshold() const {
  const ::bumoProtocol::OperationSetThreshold* p = set_threshold_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.set_threshold)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::OperationSetThreshold*>(
      &::bumoProtocol::_OperationSetThreshold_default_instance_);
}
inline ::bumoProtocol::OperationSetThreshold* Operation::release_set_threshold() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.set_threshold)
  
  ::bumoProtocol::OperationSetThreshold* temp = set_threshold_;
  set_threshold_ = NULL;
  return temp;
}
inline ::bumoProtocol::OperationSetThreshold* Operation::mutable_set_threshold() {
  
  if (set_threshold_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::OperationSetThreshold>(GetArenaNoVirtual());
    set_threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.set_threshold)
  return set_threshold_;
}
inline void Operation::set_allocated_set_threshold(::bumoProtocol::OperationSetThreshold* set_threshold) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete set_threshold_;
  }
  if (set_threshold) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      set_threshold = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, set_threshold, submessage_arena);
    }
    
  } else {
    
  }
  set_threshold_ = set_threshold;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.set_threshold)
}

// .bumoProtocol.OperationPayCoin pay_coin = 10;
inline bool Operation::has_pay_coin() const {
  return this != internal_default_instance() && pay_coin_ != NULL;
}
inline void Operation::clear_pay_coin() {
  if (GetArenaNoVirtual() == NULL && pay_coin_ != NULL) {
    delete pay_coin_;
  }
  pay_coin_ = NULL;
}
inline const ::bumoProtocol::OperationPayCoin& Operation::_internal_pay_coin() const {
  return *pay_coin_;
}
inline const ::bumoProtocol::OperationPayCoin& Operation::pay_coin() const {
  const ::bumoProtocol::OperationPayCoin* p = pay_coin_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.pay_coin)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::OperationPayCoin*>(
      &::bumoProtocol::_OperationPayCoin_default_instance_);
}
inline ::bumoProtocol::OperationPayCoin* Operation::release_pay_coin() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.pay_coin)
  
  ::bumoProtocol::OperationPayCoin* temp = pay_coin_;
  pay_coin_ = NULL;
  return temp;
}
inline ::bumoProtocol::OperationPayCoin* Operation::mutable_pay_coin() {
  
  if (pay_coin_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::OperationPayCoin>(GetArenaNoVirtual());
    pay_coin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.pay_coin)
  return pay_coin_;
}
inline void Operation::set_allocated_pay_coin(::bumoProtocol::OperationPayCoin* pay_coin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pay_coin_;
  }
  if (pay_coin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pay_coin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pay_coin, submessage_arena);
    }
    
  } else {
    
  }
  pay_coin_ = pay_coin;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.pay_coin)
}

// .bumoProtocol.OperationLog log = 11;
inline bool Operation::has_log() const {
  return this != internal_default_instance() && log_ != NULL;
}
inline void Operation::clear_log() {
  if (GetArenaNoVirtual() == NULL && log_ != NULL) {
    delete log_;
  }
  log_ = NULL;
}
inline const ::bumoProtocol::OperationLog& Operation::_internal_log() const {
  return *log_;
}
inline const ::bumoProtocol::OperationLog& Operation::log() const {
  const ::bumoProtocol::OperationLog* p = log_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.log)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::OperationLog*>(
      &::bumoProtocol::_OperationLog_default_instance_);
}
inline ::bumoProtocol::OperationLog* Operation::release_log() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.log)
  
  ::bumoProtocol::OperationLog* temp = log_;
  log_ = NULL;
  return temp;
}
inline ::bumoProtocol::OperationLog* Operation::mutable_log() {
  
  if (log_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::OperationLog>(GetArenaNoVirtual());
    log_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.log)
  return log_;
}
inline void Operation::set_allocated_log(::bumoProtocol::OperationLog* log) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete log_;
  }
  if (log) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      log = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    
  } else {
    
  }
  log_ = log;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.log)
}

// .bumoProtocol.OperationSetPrivilege set_privilege = 12;
inline bool Operation::has_set_privilege() const {
  return this != internal_default_instance() && set_privilege_ != NULL;
}
inline void Operation::clear_set_privilege() {
  if (GetArenaNoVirtual() == NULL && set_privilege_ != NULL) {
    delete set_privilege_;
  }
  set_privilege_ = NULL;
}
inline const ::bumoProtocol::OperationSetPrivilege& Operation::_internal_set_privilege() const {
  return *set_privilege_;
}
inline const ::bumoProtocol::OperationSetPrivilege& Operation::set_privilege() const {
  const ::bumoProtocol::OperationSetPrivilege* p = set_privilege_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Operation.set_privilege)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::OperationSetPrivilege*>(
      &::bumoProtocol::_OperationSetPrivilege_default_instance_);
}
inline ::bumoProtocol::OperationSetPrivilege* Operation::release_set_privilege() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Operation.set_privilege)
  
  ::bumoProtocol::OperationSetPrivilege* temp = set_privilege_;
  set_privilege_ = NULL;
  return temp;
}
inline ::bumoProtocol::OperationSetPrivilege* Operation::mutable_set_privilege() {
  
  if (set_privilege_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::OperationSetPrivilege>(GetArenaNoVirtual());
    set_privilege_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Operation.set_privilege)
  return set_privilege_;
}
inline void Operation::set_allocated_set_privilege(::bumoProtocol::OperationSetPrivilege* set_privilege) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete set_privilege_;
  }
  if (set_privilege) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      set_privilege = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, set_privilege, submessage_arena);
    }
    
  } else {
    
  }
  set_privilege_ = set_privilege;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Operation.set_privilege)
}

// -------------------------------------------------------------------

// OperationSetThreshold

// int64 tx_threshold = 1;
inline void OperationSetThreshold::clear_tx_threshold() {
  tx_threshold_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationSetThreshold::tx_threshold() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetThreshold.tx_threshold)
  return tx_threshold_;
}
inline void OperationSetThreshold::set_tx_threshold(::google::protobuf::int64 value) {
  
  tx_threshold_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationSetThreshold.tx_threshold)
}

// repeated .bumoProtocol.OperationTypeThreshold type_thresholds = 2;
inline int OperationSetThreshold::type_thresholds_size() const {
  return type_thresholds_.size();
}
inline void OperationSetThreshold::clear_type_thresholds() {
  type_thresholds_.Clear();
}
inline ::bumoProtocol::OperationTypeThreshold* OperationSetThreshold::mutable_type_thresholds(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationSetThreshold.type_thresholds)
  return type_thresholds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >*
OperationSetThreshold::mutable_type_thresholds() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.OperationSetThreshold.type_thresholds)
  return &type_thresholds_;
}
inline const ::bumoProtocol::OperationTypeThreshold& OperationSetThreshold::type_thresholds(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetThreshold.type_thresholds)
  return type_thresholds_.Get(index);
}
inline ::bumoProtocol::OperationTypeThreshold* OperationSetThreshold::add_type_thresholds() {
  // @@protoc_insertion_point(field_add:bumoProtocol.OperationSetThreshold.type_thresholds)
  return type_thresholds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::OperationTypeThreshold >&
OperationSetThreshold::type_thresholds() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.OperationSetThreshold.type_thresholds)
  return type_thresholds_;
}

// -------------------------------------------------------------------

// Transaction

// string source_address = 1;
inline void Transaction::clear_source_address() {
  source_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::source_address() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Transaction.source_address)
  return source_address_.GetNoArena();
}
inline void Transaction::set_source_address(const ::std::string& value) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.Transaction.source_address)
}
#if LANG_CXX11
inline void Transaction::set_source_address(::std::string&& value) {
  
  source_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.Transaction.source_address)
}
#endif
inline void Transaction::set_source_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.Transaction.source_address)
}
inline void Transaction::set_source_address(const char* value, size_t size) {
  
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.Transaction.source_address)
}
inline ::std::string* Transaction::mutable_source_address() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Transaction.source_address)
  return source_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_source_address() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Transaction.source_address)
  
  return source_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_source_address(::std::string* source_address) {
  if (source_address != NULL) {
    
  } else {
    
  }
  source_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_address);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Transaction.source_address)
}

// int64 nonce = 2;
inline void Transaction::clear_nonce() {
  nonce_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction::nonce() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Transaction.nonce)
  return nonce_;
}
inline void Transaction::set_nonce(::google::protobuf::int64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Transaction.nonce)
}

// int64 fee_limit = 3;
inline void Transaction::clear_fee_limit() {
  fee_limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction::fee_limit() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Transaction.fee_limit)
  return fee_limit_;
}
inline void Transaction::set_fee_limit(::google::protobuf::int64 value) {
  
  fee_limit_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Transaction.fee_limit)
}

// int64 gas_price = 4;
inline void Transaction::clear_gas_price() {
  gas_price_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction::gas_price() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Transaction.gas_price)
  return gas_price_;
}
inline void Transaction::set_gas_price(::google::protobuf::int64 value) {
  
  gas_price_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Transaction.gas_price)
}

// int64 ceil_ledger_seq = 5;
inline void Transaction::clear_ceil_ledger_seq() {
  ceil_ledger_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction::ceil_ledger_seq() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Transaction.ceil_ledger_seq)
  return ceil_ledger_seq_;
}
inline void Transaction::set_ceil_ledger_seq(::google::protobuf::int64 value) {
  
  ceil_ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Transaction.ceil_ledger_seq)
}

// bytes metadata = 6;
inline void Transaction::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::metadata() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Transaction.metadata)
  return metadata_.GetNoArena();
}
inline void Transaction::set_metadata(const ::std::string& value) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.Transaction.metadata)
}
#if LANG_CXX11
inline void Transaction::set_metadata(::std::string&& value) {
  
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.Transaction.metadata)
}
#endif
inline void Transaction::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.Transaction.metadata)
}
inline void Transaction::set_metadata(const void* value, size_t size) {
  
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.Transaction.metadata)
}
inline ::std::string* Transaction::mutable_metadata() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Transaction.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_metadata() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Transaction.metadata)
  
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    
  } else {
    
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Transaction.metadata)
}

// repeated .bumoProtocol.Operation operations = 7;
inline int Transaction::operations_size() const {
  return operations_.size();
}
inline void Transaction::clear_operations() {
  operations_.Clear();
}
inline ::bumoProtocol::Operation* Transaction::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Transaction.operations)
  return operations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Operation >*
Transaction::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.Transaction.operations)
  return &operations_;
}
inline const ::bumoProtocol::Operation& Transaction::operations(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Transaction.operations)
  return operations_.Get(index);
}
inline ::bumoProtocol::Operation* Transaction::add_operations() {
  // @@protoc_insertion_point(field_add:bumoProtocol.Transaction.operations)
  return operations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Operation >&
Transaction::operations() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.Transaction.operations)
  return operations_;
}

// -------------------------------------------------------------------

// Signer

// string address = 1;
inline void Signer::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Signer::address() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Signer.address)
  return address_.GetNoArena();
}
inline void Signer::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.Signer.address)
}
#if LANG_CXX11
inline void Signer::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.Signer.address)
}
#endif
inline void Signer::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.Signer.address)
}
inline void Signer::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.Signer.address)
}
inline ::std::string* Signer::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Signer.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signer::release_address() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Signer.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signer::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Signer.address)
}

// int64 weight = 2;
inline void Signer::clear_weight() {
  weight_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Signer::weight() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Signer.weight)
  return weight_;
}
inline void Signer::set_weight(::google::protobuf::int64 value) {
  
  weight_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Signer.weight)
}

// -------------------------------------------------------------------

// Trigger_OperationTrigger

// bytes hash = 1;
inline void Trigger_OperationTrigger::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Trigger_OperationTrigger::hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Trigger.OperationTrigger.hash)
  return hash_.GetNoArena();
}
inline void Trigger_OperationTrigger::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.Trigger.OperationTrigger.hash)
}
#if LANG_CXX11
inline void Trigger_OperationTrigger::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.Trigger.OperationTrigger.hash)
}
#endif
inline void Trigger_OperationTrigger::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.Trigger.OperationTrigger.hash)
}
inline void Trigger_OperationTrigger::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.Trigger.OperationTrigger.hash)
}
inline ::std::string* Trigger_OperationTrigger::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Trigger.OperationTrigger.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Trigger_OperationTrigger::release_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Trigger.OperationTrigger.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger_OperationTrigger::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Trigger.OperationTrigger.hash)
}

// int64 index = 2;
inline void Trigger_OperationTrigger::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Trigger_OperationTrigger::index() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Trigger.OperationTrigger.index)
  return index_;
}
inline void Trigger_OperationTrigger::set_index(::google::protobuf::int64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Trigger.OperationTrigger.index)
}

// -------------------------------------------------------------------

// Trigger

// .bumoProtocol.Trigger.TransactionType transaction_type = 1;
inline void Trigger::clear_transaction_type() {
  transaction_type_ = 0;
}
inline ::bumoProtocol::Trigger_TransactionType Trigger::transaction_type() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Trigger.transaction_type)
  return static_cast< ::bumoProtocol::Trigger_TransactionType >(transaction_type_);
}
inline void Trigger::set_transaction_type(::bumoProtocol::Trigger_TransactionType value) {
  
  transaction_type_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Trigger.transaction_type)
}

// int64 ledger_seq = 2;
inline void Trigger::clear_ledger_seq() {
  ledger_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Trigger::ledger_seq() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Trigger.ledger_seq)
  return ledger_seq_;
}
inline void Trigger::set_ledger_seq(::google::protobuf::int64 value) {
  
  ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Trigger.ledger_seq)
}

// .bumoProtocol.Trigger.OperationTrigger transaction = 3;
inline bool Trigger::has_transaction() const {
  return this != internal_default_instance() && transaction_ != NULL;
}
inline void Trigger::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) {
    delete transaction_;
  }
  transaction_ = NULL;
}
inline const ::bumoProtocol::Trigger_OperationTrigger& Trigger::_internal_transaction() const {
  return *transaction_;
}
inline const ::bumoProtocol::Trigger_OperationTrigger& Trigger::transaction() const {
  const ::bumoProtocol::Trigger_OperationTrigger* p = transaction_;
  // @@protoc_insertion_point(field_get:bumoProtocol.Trigger.transaction)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::Trigger_OperationTrigger*>(
      &::bumoProtocol::_Trigger_OperationTrigger_default_instance_);
}
inline ::bumoProtocol::Trigger_OperationTrigger* Trigger::release_transaction() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Trigger.transaction)
  
  ::bumoProtocol::Trigger_OperationTrigger* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline ::bumoProtocol::Trigger_OperationTrigger* Trigger::mutable_transaction() {
  
  if (transaction_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::Trigger_OperationTrigger>(GetArenaNoVirtual());
    transaction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Trigger.transaction)
  return transaction_;
}
inline void Trigger::set_allocated_transaction(::bumoProtocol::Trigger_OperationTrigger* transaction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transaction_;
  }
  if (transaction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Trigger.transaction)
}

// -------------------------------------------------------------------

// TransactionEnv

// .bumoProtocol.Transaction transaction = 1;
inline bool TransactionEnv::has_transaction() const {
  return this != internal_default_instance() && transaction_ != NULL;
}
inline void TransactionEnv::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) {
    delete transaction_;
  }
  transaction_ = NULL;
}
inline const ::bumoProtocol::Transaction& TransactionEnv::_internal_transaction() const {
  return *transaction_;
}
inline const ::bumoProtocol::Transaction& TransactionEnv::transaction() const {
  const ::bumoProtocol::Transaction* p = transaction_;
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnv.transaction)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::Transaction*>(
      &::bumoProtocol::_Transaction_default_instance_);
}
inline ::bumoProtocol::Transaction* TransactionEnv::release_transaction() {
  // @@protoc_insertion_point(field_release:bumoProtocol.TransactionEnv.transaction)
  
  ::bumoProtocol::Transaction* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline ::bumoProtocol::Transaction* TransactionEnv::mutable_transaction() {
  
  if (transaction_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::Transaction>(GetArenaNoVirtual());
    transaction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.TransactionEnv.transaction)
  return transaction_;
}
inline void TransactionEnv::set_allocated_transaction(::bumoProtocol::Transaction* transaction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transaction_;
  }
  if (transaction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.TransactionEnv.transaction)
}

// repeated .bumoProtocol.Signature signatures = 2;
inline int TransactionEnv::signatures_size() const {
  return signatures_.size();
}
inline ::bumoProtocol::Signature* TransactionEnv::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.TransactionEnv.signatures)
  return signatures_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signature >*
TransactionEnv::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.TransactionEnv.signatures)
  return &signatures_;
}
inline const ::bumoProtocol::Signature& TransactionEnv::signatures(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnv.signatures)
  return signatures_.Get(index);
}
inline ::bumoProtocol::Signature* TransactionEnv::add_signatures() {
  // @@protoc_insertion_point(field_add:bumoProtocol.TransactionEnv.signatures)
  return signatures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::Signature >&
TransactionEnv::signatures() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.TransactionEnv.signatures)
  return signatures_;
}

// .bumoProtocol.Trigger trigger = 3;
inline bool TransactionEnv::has_trigger() const {
  return this != internal_default_instance() && trigger_ != NULL;
}
inline void TransactionEnv::clear_trigger() {
  if (GetArenaNoVirtual() == NULL && trigger_ != NULL) {
    delete trigger_;
  }
  trigger_ = NULL;
}
inline const ::bumoProtocol::Trigger& TransactionEnv::_internal_trigger() const {
  return *trigger_;
}
inline const ::bumoProtocol::Trigger& TransactionEnv::trigger() const {
  const ::bumoProtocol::Trigger* p = trigger_;
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnv.trigger)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::Trigger*>(
      &::bumoProtocol::_Trigger_default_instance_);
}
inline ::bumoProtocol::Trigger* TransactionEnv::release_trigger() {
  // @@protoc_insertion_point(field_release:bumoProtocol.TransactionEnv.trigger)
  
  ::bumoProtocol::Trigger* temp = trigger_;
  trigger_ = NULL;
  return temp;
}
inline ::bumoProtocol::Trigger* TransactionEnv::mutable_trigger() {
  
  if (trigger_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::Trigger>(GetArenaNoVirtual());
    trigger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.TransactionEnv.trigger)
  return trigger_;
}
inline void TransactionEnv::set_allocated_trigger(::bumoProtocol::Trigger* trigger) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trigger_;
  }
  if (trigger) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trigger = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trigger, submessage_arena);
    }
    
  } else {
    
  }
  trigger_ = trigger;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.TransactionEnv.trigger)
}

// -------------------------------------------------------------------

// TransactionEnvStore

// .bumoProtocol.TransactionEnv transaction_env = 1;
inline bool TransactionEnvStore::has_transaction_env() const {
  return this != internal_default_instance() && transaction_env_ != NULL;
}
inline void TransactionEnvStore::clear_transaction_env() {
  if (GetArenaNoVirtual() == NULL && transaction_env_ != NULL) {
    delete transaction_env_;
  }
  transaction_env_ = NULL;
}
inline const ::bumoProtocol::TransactionEnv& TransactionEnvStore::_internal_transaction_env() const {
  return *transaction_env_;
}
inline const ::bumoProtocol::TransactionEnv& TransactionEnvStore::transaction_env() const {
  const ::bumoProtocol::TransactionEnv* p = transaction_env_;
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnvStore.transaction_env)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::TransactionEnv*>(
      &::bumoProtocol::_TransactionEnv_default_instance_);
}
inline ::bumoProtocol::TransactionEnv* TransactionEnvStore::release_transaction_env() {
  // @@protoc_insertion_point(field_release:bumoProtocol.TransactionEnvStore.transaction_env)
  
  ::bumoProtocol::TransactionEnv* temp = transaction_env_;
  transaction_env_ = NULL;
  return temp;
}
inline ::bumoProtocol::TransactionEnv* TransactionEnvStore::mutable_transaction_env() {
  
  if (transaction_env_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::TransactionEnv>(GetArenaNoVirtual());
    transaction_env_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.TransactionEnvStore.transaction_env)
  return transaction_env_;
}
inline void TransactionEnvStore::set_allocated_transaction_env(::bumoProtocol::TransactionEnv* transaction_env) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transaction_env_;
  }
  if (transaction_env) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction_env = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction_env, submessage_arena);
    }
    
  } else {
    
  }
  transaction_env_ = transaction_env;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.TransactionEnvStore.transaction_env)
}

// int32 error_code = 2;
inline void TransactionEnvStore::clear_error_code() {
  error_code_ = 0;
}
inline ::google::protobuf::int32 TransactionEnvStore::error_code() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnvStore.error_code)
  return error_code_;
}
inline void TransactionEnvStore::set_error_code(::google::protobuf::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.TransactionEnvStore.error_code)
}

// string error_desc = 3;
inline void TransactionEnvStore::clear_error_desc() {
  error_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionEnvStore::error_desc() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnvStore.error_desc)
  return error_desc_.GetNoArena();
}
inline void TransactionEnvStore::set_error_desc(const ::std::string& value) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.TransactionEnvStore.error_desc)
}
#if LANG_CXX11
inline void TransactionEnvStore::set_error_desc(::std::string&& value) {
  
  error_desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.TransactionEnvStore.error_desc)
}
#endif
inline void TransactionEnvStore::set_error_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.TransactionEnvStore.error_desc)
}
inline void TransactionEnvStore::set_error_desc(const char* value, size_t size) {
  
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.TransactionEnvStore.error_desc)
}
inline ::std::string* TransactionEnvStore::mutable_error_desc() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.TransactionEnvStore.error_desc)
  return error_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionEnvStore::release_error_desc() {
  // @@protoc_insertion_point(field_release:bumoProtocol.TransactionEnvStore.error_desc)
  
  return error_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionEnvStore::set_allocated_error_desc(::std::string* error_desc) {
  if (error_desc != NULL) {
    
  } else {
    
  }
  error_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_desc);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.TransactionEnvStore.error_desc)
}

// int64 ledger_seq = 4;
inline void TransactionEnvStore::clear_ledger_seq() {
  ledger_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TransactionEnvStore::ledger_seq() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnvStore.ledger_seq)
  return ledger_seq_;
}
inline void TransactionEnvStore::set_ledger_seq(::google::protobuf::int64 value) {
  
  ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.TransactionEnvStore.ledger_seq)
}

// int64 close_time = 5;
inline void TransactionEnvStore::clear_close_time() {
  close_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TransactionEnvStore::close_time() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnvStore.close_time)
  return close_time_;
}
inline void TransactionEnvStore::set_close_time(::google::protobuf::int64 value) {
  
  close_time_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.TransactionEnvStore.close_time)
}

// bytes hash = 6;
inline void TransactionEnvStore::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionEnvStore::hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnvStore.hash)
  return hash_.GetNoArena();
}
inline void TransactionEnvStore::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.TransactionEnvStore.hash)
}
#if LANG_CXX11
inline void TransactionEnvStore::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.TransactionEnvStore.hash)
}
#endif
inline void TransactionEnvStore::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.TransactionEnvStore.hash)
}
inline void TransactionEnvStore::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.TransactionEnvStore.hash)
}
inline ::std::string* TransactionEnvStore::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.TransactionEnvStore.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionEnvStore::release_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.TransactionEnvStore.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionEnvStore::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.TransactionEnvStore.hash)
}

// int64 actual_fee = 7;
inline void TransactionEnvStore::clear_actual_fee() {
  actual_fee_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TransactionEnvStore::actual_fee() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnvStore.actual_fee)
  return actual_fee_;
}
inline void TransactionEnvStore::set_actual_fee(::google::protobuf::int64 value) {
  
  actual_fee_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.TransactionEnvStore.actual_fee)
}

// -------------------------------------------------------------------

// TransactionEnvSet

// repeated .bumoProtocol.TransactionEnv txs = 2;
inline int TransactionEnvSet::txs_size() const {
  return txs_.size();
}
inline void TransactionEnvSet::clear_txs() {
  txs_.Clear();
}
inline ::bumoProtocol::TransactionEnv* TransactionEnvSet::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.TransactionEnvSet.txs)
  return txs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::TransactionEnv >*
TransactionEnvSet::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.TransactionEnvSet.txs)
  return &txs_;
}
inline const ::bumoProtocol::TransactionEnv& TransactionEnvSet::txs(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.TransactionEnvSet.txs)
  return txs_.Get(index);
}
inline ::bumoProtocol::TransactionEnv* TransactionEnvSet::add_txs() {
  // @@protoc_insertion_point(field_add:bumoProtocol.TransactionEnvSet.txs)
  return txs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::TransactionEnv >&
TransactionEnvSet::txs() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.TransactionEnvSet.txs)
  return txs_;
}

// -------------------------------------------------------------------

// ConsensusValueValidation

// repeated int32 expire_tx_ids = 1;
inline int ConsensusValueValidation::expire_tx_ids_size() const {
  return expire_tx_ids_.size();
}
inline void ConsensusValueValidation::clear_expire_tx_ids() {
  expire_tx_ids_.Clear();
}
inline ::google::protobuf::int32 ConsensusValueValidation::expire_tx_ids(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.ConsensusValueValidation.expire_tx_ids)
  return expire_tx_ids_.Get(index);
}
inline void ConsensusValueValidation::set_expire_tx_ids(int index, ::google::protobuf::int32 value) {
  expire_tx_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:bumoProtocol.ConsensusValueValidation.expire_tx_ids)
}
inline void ConsensusValueValidation::add_expire_tx_ids(::google::protobuf::int32 value) {
  expire_tx_ids_.Add(value);
  // @@protoc_insertion_point(field_add:bumoProtocol.ConsensusValueValidation.expire_tx_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConsensusValueValidation::expire_tx_ids() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.ConsensusValueValidation.expire_tx_ids)
  return expire_tx_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConsensusValueValidation::mutable_expire_tx_ids() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.ConsensusValueValidation.expire_tx_ids)
  return &expire_tx_ids_;
}

// repeated int32 error_tx_ids = 2;
inline int ConsensusValueValidation::error_tx_ids_size() const {
  return error_tx_ids_.size();
}
inline void ConsensusValueValidation::clear_error_tx_ids() {
  error_tx_ids_.Clear();
}
inline ::google::protobuf::int32 ConsensusValueValidation::error_tx_ids(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.ConsensusValueValidation.error_tx_ids)
  return error_tx_ids_.Get(index);
}
inline void ConsensusValueValidation::set_error_tx_ids(int index, ::google::protobuf::int32 value) {
  error_tx_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:bumoProtocol.ConsensusValueValidation.error_tx_ids)
}
inline void ConsensusValueValidation::add_error_tx_ids(::google::protobuf::int32 value) {
  error_tx_ids_.Add(value);
  // @@protoc_insertion_point(field_add:bumoProtocol.ConsensusValueValidation.error_tx_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConsensusValueValidation::error_tx_ids() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.ConsensusValueValidation.error_tx_ids)
  return error_tx_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConsensusValueValidation::mutable_error_tx_ids() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.ConsensusValueValidation.error_tx_ids)
  return &error_tx_ids_;
}

// -------------------------------------------------------------------

// ConsensusValue

// .bumoProtocol.TransactionEnvSet txset = 1;
inline bool ConsensusValue::has_txset() const {
  return this != internal_default_instance() && txset_ != NULL;
}
inline void ConsensusValue::clear_txset() {
  if (GetArenaNoVirtual() == NULL && txset_ != NULL) {
    delete txset_;
  }
  txset_ = NULL;
}
inline const ::bumoProtocol::TransactionEnvSet& ConsensusValue::_internal_txset() const {
  return *txset_;
}
inline const ::bumoProtocol::TransactionEnvSet& ConsensusValue::txset() const {
  const ::bumoProtocol::TransactionEnvSet* p = txset_;
  // @@protoc_insertion_point(field_get:bumoProtocol.ConsensusValue.txset)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::TransactionEnvSet*>(
      &::bumoProtocol::_TransactionEnvSet_default_instance_);
}
inline ::bumoProtocol::TransactionEnvSet* ConsensusValue::release_txset() {
  // @@protoc_insertion_point(field_release:bumoProtocol.ConsensusValue.txset)
  
  ::bumoProtocol::TransactionEnvSet* temp = txset_;
  txset_ = NULL;
  return temp;
}
inline ::bumoProtocol::TransactionEnvSet* ConsensusValue::mutable_txset() {
  
  if (txset_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::TransactionEnvSet>(GetArenaNoVirtual());
    txset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.ConsensusValue.txset)
  return txset_;
}
inline void ConsensusValue::set_allocated_txset(::bumoProtocol::TransactionEnvSet* txset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete txset_;
  }
  if (txset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      txset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, txset, submessage_arena);
    }
    
  } else {
    
  }
  txset_ = txset;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.ConsensusValue.txset)
}

// int64 close_time = 2;
inline void ConsensusValue::clear_close_time() {
  close_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ConsensusValue::close_time() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.ConsensusValue.close_time)
  return close_time_;
}
inline void ConsensusValue::set_close_time(::google::protobuf::int64 value) {
  
  close_time_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.ConsensusValue.close_time)
}

// bytes previous_proof = 3;
inline void ConsensusValue::clear_previous_proof() {
  previous_proof_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConsensusValue::previous_proof() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.ConsensusValue.previous_proof)
  return previous_proof_.GetNoArena();
}
inline void ConsensusValue::set_previous_proof(const ::std::string& value) {
  
  previous_proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.ConsensusValue.previous_proof)
}
#if LANG_CXX11
inline void ConsensusValue::set_previous_proof(::std::string&& value) {
  
  previous_proof_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.ConsensusValue.previous_proof)
}
#endif
inline void ConsensusValue::set_previous_proof(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  previous_proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.ConsensusValue.previous_proof)
}
inline void ConsensusValue::set_previous_proof(const void* value, size_t size) {
  
  previous_proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.ConsensusValue.previous_proof)
}
inline ::std::string* ConsensusValue::mutable_previous_proof() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.ConsensusValue.previous_proof)
  return previous_proof_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConsensusValue::release_previous_proof() {
  // @@protoc_insertion_point(field_release:bumoProtocol.ConsensusValue.previous_proof)
  
  return previous_proof_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConsensusValue::set_allocated_previous_proof(::std::string* previous_proof) {
  if (previous_proof != NULL) {
    
  } else {
    
  }
  previous_proof_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previous_proof);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.ConsensusValue.previous_proof)
}

// int64 ledger_seq = 4;
inline void ConsensusValue::clear_ledger_seq() {
  ledger_seq_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ConsensusValue::ledger_seq() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.ConsensusValue.ledger_seq)
  return ledger_seq_;
}
inline void ConsensusValue::set_ledger_seq(::google::protobuf::int64 value) {
  
  ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.ConsensusValue.ledger_seq)
}

// bytes previous_ledger_hash = 5;
inline void ConsensusValue::clear_previous_ledger_hash() {
  previous_ledger_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConsensusValue::previous_ledger_hash() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.ConsensusValue.previous_ledger_hash)
  return previous_ledger_hash_.GetNoArena();
}
inline void ConsensusValue::set_previous_ledger_hash(const ::std::string& value) {
  
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.ConsensusValue.previous_ledger_hash)
}
#if LANG_CXX11
inline void ConsensusValue::set_previous_ledger_hash(::std::string&& value) {
  
  previous_ledger_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.ConsensusValue.previous_ledger_hash)
}
#endif
inline void ConsensusValue::set_previous_ledger_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.ConsensusValue.previous_ledger_hash)
}
inline void ConsensusValue::set_previous_ledger_hash(const void* value, size_t size) {
  
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.ConsensusValue.previous_ledger_hash)
}
inline ::std::string* ConsensusValue::mutable_previous_ledger_hash() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.ConsensusValue.previous_ledger_hash)
  return previous_ledger_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConsensusValue::release_previous_ledger_hash() {
  // @@protoc_insertion_point(field_release:bumoProtocol.ConsensusValue.previous_ledger_hash)
  
  return previous_ledger_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConsensusValue::set_allocated_previous_ledger_hash(::std::string* previous_ledger_hash) {
  if (previous_ledger_hash != NULL) {
    
  } else {
    
  }
  previous_ledger_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previous_ledger_hash);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.ConsensusValue.previous_ledger_hash)
}

// .bumoProtocol.LedgerUpgrade ledger_upgrade = 6;
inline bool ConsensusValue::has_ledger_upgrade() const {
  return this != internal_default_instance() && ledger_upgrade_ != NULL;
}
inline const ::bumoProtocol::LedgerUpgrade& ConsensusValue::_internal_ledger_upgrade() const {
  return *ledger_upgrade_;
}
inline const ::bumoProtocol::LedgerUpgrade& ConsensusValue::ledger_upgrade() const {
  const ::bumoProtocol::LedgerUpgrade* p = ledger_upgrade_;
  // @@protoc_insertion_point(field_get:bumoProtocol.ConsensusValue.ledger_upgrade)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::LedgerUpgrade*>(
      &::bumoProtocol::_LedgerUpgrade_default_instance_);
}
inline ::bumoProtocol::LedgerUpgrade* ConsensusValue::release_ledger_upgrade() {
  // @@protoc_insertion_point(field_release:bumoProtocol.ConsensusValue.ledger_upgrade)
  
  ::bumoProtocol::LedgerUpgrade* temp = ledger_upgrade_;
  ledger_upgrade_ = NULL;
  return temp;
}
inline ::bumoProtocol::LedgerUpgrade* ConsensusValue::mutable_ledger_upgrade() {
  
  if (ledger_upgrade_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::LedgerUpgrade>(GetArenaNoVirtual());
    ledger_upgrade_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.ConsensusValue.ledger_upgrade)
  return ledger_upgrade_;
}
inline void ConsensusValue::set_allocated_ledger_upgrade(::bumoProtocol::LedgerUpgrade* ledger_upgrade) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ledger_upgrade_);
  }
  if (ledger_upgrade) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ledger_upgrade = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ledger_upgrade, submessage_arena);
    }
    
  } else {
    
  }
  ledger_upgrade_ = ledger_upgrade;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.ConsensusValue.ledger_upgrade)
}

// .bumoProtocol.ConsensusValueValidation validation = 7;
inline bool ConsensusValue::has_validation() const {
  return this != internal_default_instance() && validation_ != NULL;
}
inline void ConsensusValue::clear_validation() {
  if (GetArenaNoVirtual() == NULL && validation_ != NULL) {
    delete validation_;
  }
  validation_ = NULL;
}
inline const ::bumoProtocol::ConsensusValueValidation& ConsensusValue::_internal_validation() const {
  return *validation_;
}
inline const ::bumoProtocol::ConsensusValueValidation& ConsensusValue::validation() const {
  const ::bumoProtocol::ConsensusValueValidation* p = validation_;
  // @@protoc_insertion_point(field_get:bumoProtocol.ConsensusValue.validation)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::ConsensusValueValidation*>(
      &::bumoProtocol::_ConsensusValueValidation_default_instance_);
}
inline ::bumoProtocol::ConsensusValueValidation* ConsensusValue::release_validation() {
  // @@protoc_insertion_point(field_release:bumoProtocol.ConsensusValue.validation)
  
  ::bumoProtocol::ConsensusValueValidation* temp = validation_;
  validation_ = NULL;
  return temp;
}
inline ::bumoProtocol::ConsensusValueValidation* ConsensusValue::mutable_validation() {
  
  if (validation_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::ConsensusValueValidation>(GetArenaNoVirtual());
    validation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.ConsensusValue.validation)
  return validation_;
}
inline void ConsensusValue::set_allocated_validation(::bumoProtocol::ConsensusValueValidation* validation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete validation_;
  }
  if (validation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      validation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, validation, submessage_arena);
    }
    
  } else {
    
  }
  validation_ = validation;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.ConsensusValue.validation)
}

// -------------------------------------------------------------------

// Contract

// .bumoProtocol.Contract.ContractType type = 1;
inline void Contract::clear_type() {
  type_ = 0;
}
inline ::bumoProtocol::Contract_ContractType Contract::type() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Contract.type)
  return static_cast< ::bumoProtocol::Contract_ContractType >(type_);
}
inline void Contract::set_type(::bumoProtocol::Contract_ContractType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.Contract.type)
}

// string payload = 2;
inline void Contract::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Contract::payload() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.Contract.payload)
  return payload_.GetNoArena();
}
inline void Contract::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.Contract.payload)
}
#if LANG_CXX11
inline void Contract::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.Contract.payload)
}
#endif
inline void Contract::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.Contract.payload)
}
inline void Contract::set_payload(const char* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.Contract.payload)
}
inline ::std::string* Contract::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.Contract.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Contract::release_payload() {
  // @@protoc_insertion_point(field_release:bumoProtocol.Contract.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Contract::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.Contract.payload)
}

// -------------------------------------------------------------------

// OperationCreateAccount

// string dest_address = 1;
inline void OperationCreateAccount::clear_dest_address() {
  dest_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationCreateAccount::dest_address() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationCreateAccount.dest_address)
  return dest_address_.GetNoArena();
}
inline void OperationCreateAccount::set_dest_address(const ::std::string& value) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationCreateAccount.dest_address)
}
#if LANG_CXX11
inline void OperationCreateAccount::set_dest_address(::std::string&& value) {
  
  dest_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationCreateAccount.dest_address)
}
#endif
inline void OperationCreateAccount::set_dest_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationCreateAccount.dest_address)
}
inline void OperationCreateAccount::set_dest_address(const char* value, size_t size) {
  
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationCreateAccount.dest_address)
}
inline ::std::string* OperationCreateAccount::mutable_dest_address() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationCreateAccount.dest_address)
  return dest_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationCreateAccount::release_dest_address() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationCreateAccount.dest_address)
  
  return dest_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationCreateAccount::set_allocated_dest_address(::std::string* dest_address) {
  if (dest_address != NULL) {
    
  } else {
    
  }
  dest_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_address);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationCreateAccount.dest_address)
}

// .bumoProtocol.Contract contract = 2;
inline bool OperationCreateAccount::has_contract() const {
  return this != internal_default_instance() && contract_ != NULL;
}
inline void OperationCreateAccount::clear_contract() {
  if (GetArenaNoVirtual() == NULL && contract_ != NULL) {
    delete contract_;
  }
  contract_ = NULL;
}
inline const ::bumoProtocol::Contract& OperationCreateAccount::_internal_contract() const {
  return *contract_;
}
inline const ::bumoProtocol::Contract& OperationCreateAccount::contract() const {
  const ::bumoProtocol::Contract* p = contract_;
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationCreateAccount.contract)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::Contract*>(
      &::bumoProtocol::_Contract_default_instance_);
}
inline ::bumoProtocol::Contract* OperationCreateAccount::release_contract() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationCreateAccount.contract)
  
  ::bumoProtocol::Contract* temp = contract_;
  contract_ = NULL;
  return temp;
}
inline ::bumoProtocol::Contract* OperationCreateAccount::mutable_contract() {
  
  if (contract_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::Contract>(GetArenaNoVirtual());
    contract_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationCreateAccount.contract)
  return contract_;
}
inline void OperationCreateAccount::set_allocated_contract(::bumoProtocol::Contract* contract) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete contract_;
  }
  if (contract) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contract = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    
  } else {
    
  }
  contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationCreateAccount.contract)
}

// .bumoProtocol.AccountPrivilege priv = 3;
inline bool OperationCreateAccount::has_priv() const {
  return this != internal_default_instance() && priv_ != NULL;
}
inline void OperationCreateAccount::clear_priv() {
  if (GetArenaNoVirtual() == NULL && priv_ != NULL) {
    delete priv_;
  }
  priv_ = NULL;
}
inline const ::bumoProtocol::AccountPrivilege& OperationCreateAccount::_internal_priv() const {
  return *priv_;
}
inline const ::bumoProtocol::AccountPrivilege& OperationCreateAccount::priv() const {
  const ::bumoProtocol::AccountPrivilege* p = priv_;
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationCreateAccount.priv)
  return p != NULL ? *p : *reinterpret_cast<const ::bumoProtocol::AccountPrivilege*>(
      &::bumoProtocol::_AccountPrivilege_default_instance_);
}
inline ::bumoProtocol::AccountPrivilege* OperationCreateAccount::release_priv() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationCreateAccount.priv)
  
  ::bumoProtocol::AccountPrivilege* temp = priv_;
  priv_ = NULL;
  return temp;
}
inline ::bumoProtocol::AccountPrivilege* OperationCreateAccount::mutable_priv() {
  
  if (priv_ == NULL) {
    auto* p = CreateMaybeMessage<::bumoProtocol::AccountPrivilege>(GetArenaNoVirtual());
    priv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationCreateAccount.priv)
  return priv_;
}
inline void OperationCreateAccount::set_allocated_priv(::bumoProtocol::AccountPrivilege* priv) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete priv_;
  }
  if (priv) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      priv = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, priv, submessage_arena);
    }
    
  } else {
    
  }
  priv_ = priv;
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationCreateAccount.priv)
}

// repeated .bumoProtocol.KeyPair metadatas = 4;
inline int OperationCreateAccount::metadatas_size() const {
  return metadatas_.size();
}
inline ::bumoProtocol::KeyPair* OperationCreateAccount::mutable_metadatas(int index) {
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationCreateAccount.metadatas)
  return metadatas_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bumoProtocol::KeyPair >*
OperationCreateAccount::mutable_metadatas() {
  // @@protoc_insertion_point(field_mutable_list:bumoProtocol.OperationCreateAccount.metadatas)
  return &metadatas_;
}
inline const ::bumoProtocol::KeyPair& OperationCreateAccount::metadatas(int index) const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationCreateAccount.metadatas)
  return metadatas_.Get(index);
}
inline ::bumoProtocol::KeyPair* OperationCreateAccount::add_metadatas() {
  // @@protoc_insertion_point(field_add:bumoProtocol.OperationCreateAccount.metadatas)
  return metadatas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bumoProtocol::KeyPair >&
OperationCreateAccount::metadatas() const {
  // @@protoc_insertion_point(field_list:bumoProtocol.OperationCreateAccount.metadatas)
  return metadatas_;
}

// int64 init_balance = 5;
inline void OperationCreateAccount::clear_init_balance() {
  init_balance_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationCreateAccount::init_balance() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationCreateAccount.init_balance)
  return init_balance_;
}
inline void OperationCreateAccount::set_init_balance(::google::protobuf::int64 value) {
  
  init_balance_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationCreateAccount.init_balance)
}

// string init_input = 6;
inline void OperationCreateAccount::clear_init_input() {
  init_input_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationCreateAccount::init_input() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationCreateAccount.init_input)
  return init_input_.GetNoArena();
}
inline void OperationCreateAccount::set_init_input(const ::std::string& value) {
  
  init_input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationCreateAccount.init_input)
}
#if LANG_CXX11
inline void OperationCreateAccount::set_init_input(::std::string&& value) {
  
  init_input_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationCreateAccount.init_input)
}
#endif
inline void OperationCreateAccount::set_init_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  init_input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationCreateAccount.init_input)
}
inline void OperationCreateAccount::set_init_input(const char* value, size_t size) {
  
  init_input_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationCreateAccount.init_input)
}
inline ::std::string* OperationCreateAccount::mutable_init_input() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationCreateAccount.init_input)
  return init_input_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationCreateAccount::release_init_input() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationCreateAccount.init_input)
  
  return init_input_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationCreateAccount::set_allocated_init_input(::std::string* init_input) {
  if (init_input != NULL) {
    
  } else {
    
  }
  init_input_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), init_input);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationCreateAccount.init_input)
}

// -------------------------------------------------------------------

// OperationSetMetadata

// string key = 1;
inline void OperationSetMetadata::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationSetMetadata::key() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetMetadata.key)
  return key_.GetNoArena();
}
inline void OperationSetMetadata::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationSetMetadata.key)
}
#if LANG_CXX11
inline void OperationSetMetadata::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationSetMetadata.key)
}
#endif
inline void OperationSetMetadata::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationSetMetadata.key)
}
inline void OperationSetMetadata::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationSetMetadata.key)
}
inline ::std::string* OperationSetMetadata::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationSetMetadata.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationSetMetadata::release_key() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationSetMetadata.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetMetadata::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationSetMetadata.key)
}

// string value = 2;
inline void OperationSetMetadata::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperationSetMetadata::value() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetMetadata.value)
  return value_.GetNoArena();
}
inline void OperationSetMetadata::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationSetMetadata.value)
}
#if LANG_CXX11
inline void OperationSetMetadata::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bumoProtocol.OperationSetMetadata.value)
}
#endif
inline void OperationSetMetadata::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bumoProtocol.OperationSetMetadata.value)
}
inline void OperationSetMetadata::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bumoProtocol.OperationSetMetadata.value)
}
inline ::std::string* OperationSetMetadata::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:bumoProtocol.OperationSetMetadata.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationSetMetadata::release_value() {
  // @@protoc_insertion_point(field_release:bumoProtocol.OperationSetMetadata.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetMetadata::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:bumoProtocol.OperationSetMetadata.value)
}

// int64 version = 3;
inline void OperationSetMetadata::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 OperationSetMetadata::version() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetMetadata.version)
  return version_;
}
inline void OperationSetMetadata::set_version(::google::protobuf::int64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationSetMetadata.version)
}

// bool delete_flag = 4;
inline void OperationSetMetadata::clear_delete_flag() {
  delete_flag_ = false;
}
inline bool OperationSetMetadata::delete_flag() const {
  // @@protoc_insertion_point(field_get:bumoProtocol.OperationSetMetadata.delete_flag)
  return delete_flag_;
}
inline void OperationSetMetadata::set_delete_flag(bool value) {
  
  delete_flag_ = value;
  // @@protoc_insertion_point(field_set:bumoProtocol.OperationSetMetadata.delete_flag)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bumoProtocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::bumoProtocol::Operation_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bumoProtocol::Operation_Type>() {
  return ::bumoProtocol::Operation_Type_descriptor();
}
template <> struct is_proto_enum< ::bumoProtocol::Transaction_Limit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bumoProtocol::Transaction_Limit>() {
  return ::bumoProtocol::Transaction_Limit_descriptor();
}
template <> struct is_proto_enum< ::bumoProtocol::Signer_Limit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bumoProtocol::Signer_Limit>() {
  return ::bumoProtocol::Signer_Limit_descriptor();
}
template <> struct is_proto_enum< ::bumoProtocol::Trigger_TransactionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bumoProtocol::Trigger_TransactionType>() {
  return ::bumoProtocol::Trigger_TransactionType_descriptor();
}
template <> struct is_proto_enum< ::bumoProtocol::Contract_ContractType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bumoProtocol::Contract_ContractType>() {
  return ::bumoProtocol::Contract_ContractType_descriptor();
}
template <> struct is_proto_enum< ::bumoProtocol::Limit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bumoProtocol::Limit>() {
  return ::bumoProtocol::Limit_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_chain_2eproto
